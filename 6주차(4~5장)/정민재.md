# [6회차 07.14.] 4, 5장

# 4장 서버사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

- 싱글 페이지 애플리케이션이란?
    - 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 말한다.
- 최초에 페이지를 불러온 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리하므로 싱글 페이지 애플리케이션이라고 한다.
- 사이트 렌더링에 필요한 내부 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링 한다.
- 페이지 전환 시에도 새로운 HTML 페이지를 요청하지 않고 자바스크립트에서 다음 페이지 렌더링에 필요한 정보만 HTTP 요청 등으로 가져와서 추가, 수정, 삭제하는 방법으로 페이지를 전환한다.

### 4.1.2 서버 사이드 렌더링이란?

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식
- 싱글 페이지 애플리케이션과의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐다.
- 장점
    - 최초 페이지 진입이 빠르다
    - 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.
    - 누적 레이아웃 이동이 적다
    - 사용자의 디바이스 성능에 비교적 자유롭다
    - 보안에 좀 더 안전하다
- 단점
    - 소스코드를 작성할 때 항상 서버를 고려해야 한다
    - 적절한 서버가 구축돼 있어야 한다
    - 서비스 지연에 따른 문제

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

- 서버 사이드 렌더링 역시 만능은 아니다.
    - 서버 사이드 렌더링은 모든 문제의 해결책이 될 수 없다.
    - 웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지
    어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다.
    - 설계와 목적, 우선순위에 따라 싱글 페이지 어플리케이션이 더 효율적일 수도 있다.
- 두 방법론 모두 상황에 따라 유효한 방법이다.
    - 모두 장단점이 있으며 어느 하나가 완벽하다고 볼 수 없다.
- 현대의 서버 사이드 렌더링은 최초 웹사이트 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글페이지 애플리케이션처럼 작동한다.

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

### 4.2.1 renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수다.
- 최초의 페이지를 HTML로 먼저 렌더링해주는 역할을 하는 함수다.

### 4.2.2 renderToStaticMarkup

- renderToString과 유사하나 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
- 리액트의 이벤트 리스너가 필요 없는 완전 순수한 HTML만을 만들 때만 사용된다.
- 블로그 글이나 상품의 약관 정보와 같이 아무런 브라우저 액션이 없는 정적인 내용만 필요한 경우에 유용하다.

### 4.2.3 renderToNodeStream

- renderToString과 결과물이 완전 동일하지만 두가지 차이점이 있다.
    - renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능하다.
    - renderToString은 결과물이 문자열이지만, renderToNodeStream은 결과물이 Node.js의 ReadableStream(utf-8로 인코딩된 바이트 스트림) 이다.
- ReadableStream
    - 브라우저에서도 사용할 수 있는 객체지만 만드는 과정은 브라우저에서 불가능하게 구현돼 있다.
    - 브라우저에 제공해야 할 큰 HTML을 작은 단위로 쪼개 연속적으로 작성함으로써 리액트 애플리케이션을 렌더링하는 Node.js의 부담을 덜어준다.

### 4.2.4 renderToStaticNodeStream

- renderToNodeStream과 제공하는 결과물은 동일하나, renderToStaticMarkup과 마찬가지로 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.
- hydrate를 할 필요 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드다.

### 4.2.5 hydrate

- renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- 정적으로 생성된 HTML에 이벤트와 핸들러를 붙여 완전한 웹페이지 결과물을 만든다.
- render함수와 비슷한 역할을 하지만 hydrate는 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다.

### 4.2.6 서버 사이드 렌더링 예제 프로젝트

- 리액트 팀도 리액트 서버 사이드 렌더링을 직접 구현해 사용하는 것보다는 Next.js 같은 프레임워크를 사용하는 것을 권장하고 있다.

### 4.2.7 정리

- 어느 정도 성능이 보장된 서버 사이드 렌더링을 수행하려면 매우 복잡한 코드가 필요하며,
이를 매번 개발자 개인이 작성하는 것은 매우 비효율적이다.

## 4.3 Next.js 톺아보기

### 4.3.1 Next.js란?

- Vercel에서 만든 리액트 기반 서버 사이드 렌더링 프레임워크다.

### 4.3.2 Next.js 시작하기

- next/link로 이동하는 경우 서버 사이드 렌더링이 아닌, 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식으로 작동한다.
- getServerSideProps 함수가 페이지에 없으면 서버에서 실행하지 않아도 되는 페이지로 처리한다.
- Next.js는 서버 사이드 렌더링 프레임워크지만 모든 작업이 서버에서 일어나는 것은 아니다.

### 4.3.3 Data Fetching

- Next.js에는 서버사이드 렌더링을 지원하기 위한 몇 가지 데이터 불러오기 전략이 있는데, 이를 Data Fetching이라고 한다.
- HTML을 렌더링할 때 필요한 데이터를 미리 가져와서 그 결과물을 HTML에 포함시키는 것과 비슷

### 4.3.4 스타일 적용하기

- 전역 스타일은 _app.tsx를 활용
- 컴포넌트 레벨 CSS는 [name].module.css와 같이 명명한다.
- 컴포넌트 레벨 CSS는 다른 컴포넌트의 클래스명과 충돌이 일어나지 않도록 고유한 클래스명을 제공한다.
- 자바스크립트 내부에 스타일 시트를 삽입하는 CSS-in-JS 라이브러리는 styled-jsx, styled-components 등이 있으며 styled-components가 가장 많은 사용자를 보유하고 있다.

### 4.3.5 _app.tsx 응용하기

- _app.tsx는 Next.js로 만든 모든 서비스가 진입하는 최초 진입점이다.
- 사용자가 처음 서비스에 접근했을 때 동작을 처리할 수 있다.

### 4.3.6 next.config.js 살펴보기

- Next.js 실행에 필요한 설정을 추가할 수 있는 파일

---

# 5장 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

- 상태란
    - 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값
- 대표적으로 상태로 분류될 수 있는 것들
    - UI : 상태라 함은 상호 작용이 가능한 모든 요소의 현재 값을 의미한다.
    다크/라이트 모드, 라디오 등 많은 종류의 상태가 존재한다.
    - URL : 브라우저에서 관리되고 있는 상태값이다. 사용자의 라우팅에 따라 변경된다.
    - 폼(form) : 로딩 중인지(loading), 현재 제출됐는지(submit), 접근이 불가능한지(disabled), 값이 유효한지(validation) 등 모두 상태로 관리된다.
    - 서버에서 가져온 값 : 클라이언트에서 서버 요청을 통해 가져온 값, 대표적으로 API 요청이 있다.

### 5.1.1 리액트 상태 관리의 역사

- 리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐, 그 이상의 기능을 제공하지 않고 있다. 따라서 개발자 성향이나 시간에 따라 상태를 관리하는 방법에 많은 차이가 있다.
- **Flux 패턴의 등장**
    - 문제의 원인을 양방향이 아닌, 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 바로 Flux 패턴의 시작이다.
    - 단방향 데이터 흐름 방식은 당연히 불편함도 존재한다.
    사용자의 입려에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 수고로워진다
    - 그러나 데이터의 흐름은 모두 액션이라는 한 방향으로 줄어들므로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기 한결 수월해진다.
- **시장 지배자 리덕스의 등장**
    - 리덕스 또한 Flex 구조를 구현하기 위해 만들어진 라이브러 중 하나였다.
    한가지 특별한 것은 Elm 아키텍처를 도입했다는 것이다.
    - **Elm**은 웹페이지를 선언적으로 작성하기 위한 언어다.
        - model, view, update 세 가지로 데이터 흐름을 분류하고 단방향으로 강제해 웹 어플리케이션의 상태를 안정적으로 관리하고자 노력했다.
    - 하나의 글로벌 상태를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props를깊이 전파해야 하는 이른바 prop 내려주기 문제를 해결 할 수 있었고,
    스토어가 필요한 컴포넌트라면 단지 connect만 쓰면 스토어에 바로 접근할 수 있다.
    - 리덕스가 마냥 편하기만 한 것은 아니었다.
        - 하나의 상태를 변경하기 위해서 해야 할 일이 너무 많았다.
        - 하는 일에 비해 보일러플레이트가 너무 많다는 비판이 있었지만 지금은 이러한 작업이 많이 간소화됐다.
- **Context API와 useContext**
    - 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시 했다.
    - props로 상태를 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 되었다.
    - Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능이 존재하지 않으니 사용할 때 주의가 필요하다.
- **훅의 탄생, 그리고 REact Query와 SWR**
    - state를 매우 손쉽게 재사용 가능하도록 만들 수 있가는 것이다.
    - React Query와 SWR은 외부에서 데이터를 불러오는 fetch를 관리하는데 특화된 라이브러리다.
- **Recoil, Zustand, Jotai, Valtio에 이르기까지**
    - 훅이라는 새로운 패러다임의 등장에 따라, 훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장한다.
    - 리덕스와 차이점은 별도 라이브러리 설치 없이 훅을 이용해 작은 크기의 상태를 효율적으로 관리할 수 있다.
    - 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만듦.
    - 함수형 컴포넌트에서 손쉽게 사용 가능.

## 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법: useState와 useReducer

- useState의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됐다.
- 리액트 훅을 기반으로 만든 사용자 정의 훅은 함수 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점이 있다.
- useReducer 또한 지역 상태를 관리할 수 있는 훅이다.
- useState는 useReducer로 구현됐다.
- 기본적인 useState를 기반으로 한 상태를 지역 상태라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

- 로직을 재사용할 수 있도록 Custom Hook을 만들어 useState와 다른 로직을 포함시킬 수 있다. 이 방법은 상태 관리 로직을 컴포넌트로부터 분리하고 싶을 때 유용하다.
    
    ```jsx
    import { useState } from "react";
    
    // Custom Hook 정의, 초기값을 매개변수로 받는다.
    function useCustomState(initialValue) {
      // useState를 사용하여 상태와 상태를 업데이트하는 함수 초기화.
      const [value, setValue] = useState(initialValue);
    
      // 상태에 대해 수행할 수 있는 추가적인 커스텀 로직 정의
      function doSomethingWithValue() {
        //  상태 값을 사용하여 수행할 작업 정의
      }
    
      // 커스텀 훅에서 상태 값, 상태를 업데이트하는 함수, 정의한 추가 로직을 반환
      return [value, setValue, doSomethingWithValue];
    }
    
    // useCustomState를 호출하여 상태 값, 상태를 업데이트하는 함수 추가 로직을 사용
    function SomeComponent() {
      const [value, setValue, doSomethingWithValue] = useCustomState(0); //    Custom Hook 사용, 초기 상태 값으로 0을 설정
    
      // 컴포넌트의 나머지 부분에서 value, setValue, doSomethingWithValue를 사용
    }
    
    ```
    

### 5.2.3 useState와 Context를 동시에 사용해 보기

```jsx
import React, { useState, useContext } from "react";

// Context 생성
const StateContext = React.createContext();

// Context를 제공하는 컴포넌트
export function StateProvider({ children }) {
  const [state, setState] = useState(initialState);

  return (
    <StateContext.Provider value={{ state, setState }}>
      {children}
    </StateContext.Provider>
  );
}

// Context를 사용하는 컴포넌트에서는 useContext 훅을 이용
function SomeComponent() {
  const { state, setState } = useContext(StateContext);

  // 이제 state와 setState를 사용할 수 있음
}

```

### 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

- 각 라이브러리는 상태 관리를 단순화하고 효율적으로 만들기 위해 고안되었으며, 각각의 고유한 특성과 접근 방식을 가지고 있다.
    
    ### 1. Recoil
    
    - Recoil은 Facebook에서 개발한 React용 상태 관리 라이브러리로, React의 훅과 같은 기능을 사용하여 편리한 상태 관리를 제공한다. Recoil은 atoms와 selectors를 사용하여 상태를 관리한다.
    - Recoil은 React의 Context API와 유사한 패턴을 사용하지만, 더욱 세밀한 구독 관리와 효율적인 업데이트를 가능하게 합니다.
    
    ### 2. Jotai
    
    - Jotai는 "minimalist" 상태 관리 라이브러리로, Recoil과 유사한 개념을 사용하지만, 더 간단하고 직관적인 API를 제공한다. Jotai도 atoms를 사용하여 상태를 관리하며, React의 Context API에 의존하지 않고도 상태를 전역적으로 관리할 수 있다.
    - Jotai는 상태 로직을 컴포넌트로부터 분리하고, 필요한 컴포넌트에만 상태를 주입하여 성능 최적화를 돕는다.
    
    ### 3. Zustand
    
    - Zustand는 Redux와 같은 전통적인 상태 관리 라이브러리보다 훨씬 적은 설정과 보일러플레이트 코드를 요구한다. Zustand는 상태를 하나의 저장소(store)에서 관리하며, React 컴포넌트 외부에서도 상태를 쉽게 업데이트하고 구독할 수 있다.
    - Zustand는 특히 작고 간단한 애플리케이션에서 상태 관리를 쉽게하기 위해 설계되었으며, 미들웨어를 사용하여 기능을 확장할 수 있다.

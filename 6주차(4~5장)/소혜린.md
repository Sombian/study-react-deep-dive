# 4장 서버 사이드 렌더링


### 4.1 서버 사이드 렌더링이란?

##### 4.1.1 싱를 페이지 애플리케이션의 세상

- 싱글 페이지 애플리케이션이란?

렌더링과 라우티에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식이다.

최초에 첫 페이지에서 모든 데이터를 불러오고 이후 페이지 전환을 위한 모든 작업은 자바스크립트와 브라우저의 history.pushState history.replaceState 로 이루어진다.

실제로 크롬 개발자 도구의 소스 보기를 들어가보면 태그 내부에 아무 내용이 없다. 자바스크립트 코드로 렌더링하기 때문이다.

장점: 초기 로딩 속도가 느리고 초기 로드하는 데이터 양이 많다.

단점: 초기 로딩 이후에는 서버를 거치지 않아도 되기 때문에 사용자에게 UI/UX 측면에서 훌륭하다.

- 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

PHP, JSP 기반 웹 앱은 서버 사이드 렌더링에서 이뤄진다. 이후 CommonJS, AMD의 등장으로 자바스크립트가 서서히 다양한 작업을 수행하게 된다.

2010년에 Backbone.js, AngularJS, Knockout.js의 등장하면서 자바스크립트 역할과 규모가 점점 커졌다.

그리고 React, Vue, Angular의 등장으로 싱글 페이지 애플리케이션의 인기가 시작된다.

이 인기에 힘입어 JAM 스택이 등장한다.
- JavaScript | API | Markup

이후 MEAN 스택이나 MERN 스택처럼 API 서버도 자바스크립트로 구현하는 구조가 인기를 얻는다.
- MongoDB | Express.js | AngularJS | Node.js
- MongoDB | Express.js | React | Node.js

##### 4.1.2 서버 사이드 렌더링이란?

- 도입 배경

앞서 싱글 페이지 애플리케이션의 단점이 자바스크립트가 처길 수록 점점 웹페이지가 느려질 수 밖에 없다는 것이다.이 상황에 대한 문제 의식을 한계로 두고 이를 개선하고자 서버 사이드 렌더링 방식이 다시 떠오르고 있다.

CSR: 자바스크립트 번들에서 렌더링을 담당

SSR: 서버에서 렌더링 담당

CSR은 사용자 기기의 성능에 영향을 받지만 SSR은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능

- 서버 사이드 렌더링의 장점

1. 최초 페이지 진입이 비교적 빠르다.

2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

3. 로봇이 페이지에 진입
	- 로봇이 html을 다운로드 (자바스크립트 코드는 실행하지 않음)
	- 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 검색 엔진에 저장
4. 누적 레이아웃 이동이 적다.
	- 누적 레이아웃 이동: 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것 같은 부정적 사용자 경험
	- 서버 사이드 렌더링은 요청이 완전히 완료된 이후에 완성된 페이지를 제공하기 때문에 이런 문제가 적다.
5. 사용자의 디바이스 성능에 비교적 자유롭다.
6. 보안에 좀 더 안전하다.
	- 애플리케이션의 모든 활동이 브라우저에 노출되지 않고 인증 또는 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공

- 서버 사이드 렌더링의 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다.
2. 적절한 서버가 구축되어 있어야 한다.
3. 서비스 지연에 따른 문제
	- 최초 렌더링에 지연이 발생된다면 서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기 까지 사용자에게 그 어떤 정보도 제공할 수 없다 → dynamic import 나 Suspense 같은 것들로 개선 중

##### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

1. 서버 사이드 렌더링 역시 만능이 아니다.
	- 관리 포인트만 클라이언트에서 클라이언트 + 서버로 늘어나게 하는 역효과가 될 수 있다.
2. 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션
	- 멀티 페이지 애플리케이션 : 서버 사이드 렌더링
	- 멀티 페이지 애플리케이션에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 다양한 API (아래 기법들을 SPA에서 구현하기 위해서는 복잡한 과정을 거쳐야 하지만 멀티 페이지 애플리케이션에서는 API를 통해 제공이 됨)
		- 페인트 홀딩: 같은 출처에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
		- back forward cache: 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
		- Shared Element Transitions: 페이지 라우팅이 일어났을 때, 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법
3. 현대의 서버 사이드 렌더링
	- CSR과 SSR의 장점을 모두 취한 방식으로 작동하게 변화 중
	- 최초 웹 사이트 진입 시에는 서버에서 완성된 HTML 제공, 이 후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 싱글 페이지 애플리케이션처럼 작동
	- Next.js, Remix

### 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

리액트 앱을 서버에서 렌더링 할 수 있는 API는 Node.js 같은 서버 환경에서만 실행 가능하다.

##### 4.2.1 renderToString

- 인수로 넘겨 받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 서버 사이드 렌더링에서 최초의 페이지를 HTML로 먼저 렌더링하는 역할

##### 4.2.2 renderToStaticMarkup

- renderToString 함수와 유사
- 차이점은 리액트에서만 사용하는 추가적인 DOM 속성은 만들지 않음

##### 4.2.3 renderToNodeStream

- renderToString과 결과물이 완전히 동일
- 차이점은 renderToNodeStream은 브라우저에서 사용이 불가능하고 결과물의 타입이 string이 아니라 ReadableStream 이다.
- 청크 타입으로 분리되어 내려오기 때문에 서버의 부담을 덜 수 있어서 대부분의 프레임워크에 사용되고 있다.

##### 4.2.4 renderToStaticNodeStream

- renderToNodeStream 과 제공하는 결과물은 동일하나 리액트 속성이 제공되지 않는다.

##### 4.2.5 hydrate

- renderToString과 renderToNodeStream 으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할

### 4.3 Next.js 톺아보기

##### 4.3.1 Next.js 란?

- vercel 에서 만든 리액트 기반 서버 사이드 렌더링 프레임워크

##### 4.3.2 Next.js 시작하기

- \_app.tsx 와 \_document.tsx의 차이점
  - \_app.tsx
    - Next.js를 초기화하는 파일로 Next.js 설정과 관련된 코드를 모아두는 곳
    - 서버나 클라이언트에서 모두 실행 가능
  - \_document.tsx
    - Next.js로 만드는 웹사이트의 뼈대가 되는 HTML 설정과 관련된 코드를 추가하는 곳
    - 무조건 서버에서 실행 (이벤트 추가 불가)
- 라우팅
  - `[]`안의 내용은 변수로 처리
  - 전개 연산자로 처리하면 배열로 들어간다.
- getServerSideProps가 있으면 서버 사이드 렌더링 페이지로 들어가고 없으면 빌드 시점에 미리 만들어버리는 페이지가 된다.
- api 디렉터리는 서버의 API를 정의하는 폴더
  - 서버에서 내려주는 데이터를 조합해 BFF 형태로 활용할 때
  - 완전한 풀스택 애플리케이션을 구축하고 싶을 때
  - CORS 문제를 우회하고 싶을 때 사용 가능

##### 4.3.3 Data Fetching

- 데이터 불러오기 전략
- getStaticPaths와 getStaticProps
  - 게시판, 공지같이 사용자와 관계없이 정적으로 결정된 페이지를 보여줄 때 사용
  - 두 가지는 세트로 함께 있어야 한다.
- getServerSideProps
  - 응답값에 따라 페이지의 루트 컴포넌트에 props를 반환할 수도 혹은 다른 페이지로 리다이렉트시킬 수도 있다.
  - 서버에서만 실행되기 때문에 발생되는 제약
    - window.document 같이 브라우저에서만 접근할 수 있는 객체에는 접근 불가
    - protocol과 domain 없이 fetch 요청이 불가 (자신의 호스트를 유추할 수 없기 때문)
    - 여기서 에러가 발생하면 500.tsx 같은 에러 페이지로 리다이렉트
- getInitialProps
  - 레거시이므로 왠만하면 getStaticProps나 getServerSideProps를 사용하자
  - 서버와 클라이언트 모두에서 실행될 수 있음

##### 4.3.4 스타일 적용하기

- 전역 스타일
  - resetCSS 등 전체에 공통으로 적용하고 싶은 스타일은 \_app.tsx를 활용해서 필요한 스타일을 직접 import로 불러오자
- 컴포넌트 레벨 CSS
  - `[name].module.css` 같은 명명 규칙으로 컴포넌트 단위로 CSS를 적용할 수 있다.
- SCSS와 SASS
  - 위와 동일하게 작성 가능
- CSS-in-JS
  - \_document.js 에 코드를 추가해서 작성

### 4.3.5 \_app.tsx 응용하기

- Next.js로 만든 모든 서비스가 진입하는 최초 진입점
- `app.getInitialProps` 내부에 웹 서비스를 최초에 접근했을 때만 실행하고 싶은 내용을 담아둘 수 있다.
  - userAgent 확인
  - 사용자 정보와 같은 애플리케이션 전역에서 사용해야 하는 정보

##### 4.3.6 next.config.js 살펴보기

- Next.js 실행에 필요한 설정을 추가할 수 있는 파일
- `basePath` : 기본적으로 앱을 실행했을 때 시작되는 path `localhost:3000/docs`
- `swcMinify` : swc를 이용해 코드를 압축할지 true/false
- `poweredByHeader` : 응답 헤더에 next.js 정보를 제공할지 결정 true/false
- `redirects` : 특정 주소를 다른 주소로 보내고 싶을 때 사용
- `reactStrictMode` : 리액트 엄격 모드 true/false
- `assetPrefix` : next에서 빌드된 결과물을 동일한 호스트가 아닌 다른 CDN에 업로드하려면 이 옵션에 CDN 주소를 명시


# 5장 리액트와 상태 관리 리액트와 상태 관리 라이브러리

### 5.1 상태 관리는 왜 필요한가?

웹 애플리케이션을 개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

##### 5.1.1 리액트 상태 관리의 역사

**Flux 패턴의 등장**

리액트에서 Context API가 선보인 것은 16.3, useContext를 선보인 것은 16.8이었다.

리덕스가 나타나기 전까지는 리액트 애플리케이션에서 딱히 이름을 널리 알린 상태 관리 라이브러리는 없었다.

- 2014년 경 Flux가 소개됨
애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추적하고 이해하기가 매우 어려운 상황이였음

- 페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인딩으로 봤음(뷰(HTML)가 모델(자바스크립트)을 변경할 수 있으며, 반대도 가능한 것) 이는 코드의 양도 많이지고, 변경 시나리오가 복잡해질수록 관리가 어려워짐

- 따라서 페이스북 팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하고, 이것이 Flux 패턴의 시작

- 액션 > 디스패처 > 스토어 > 뷰 > 액션

**시장 지배자 리덕스 등장**

리덕스는 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나였음

- 리덕스는 Elm 아키텍처의 영향을 받아 작성됐음
  + Elm은 웹페이지를 선언적으로 작성하기 위한 언어
  + Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력

- But, 하고자 하는 일에 비해 보일러플레이트가 너무 많다는 비판의 목소리

**Context API와 useContext**

- 리액트 16.3 이전에도 context가 존재는 했고, 이를 다루기 위해 getChildContext()가 제공되었음
  - 상위 컴포넌트가 렌더링되면 getChildContext가 호출됨과 동시에 shouldComponentUpdate가 항상 true를 반환해 불필요하게 렌더링이 일어난다는 점
  - 사용하기 위해 context를 인수로 받아야해 컴포넌트와 결합도가 높아지는 등의 단점이 존재했음

이러한 문제를 해결하기 위해 Context API가 등장함

하지만 Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다.


### 5.2 리액트 훅으로 시작하는 상태 관리

##### 5.2.1 가장 기본적인 방법: useState와 useReducer

- 관리해야 하는 상태가 복잡하거나 상태를 변경할 수 있는 시나리오가 다양해진다면, 사용자 정의 훅을 통해 격리하여 제공할 수 있다는 장점이 더욱 크게 드러날 것

##### 컴포넌트 밖에서 상태를 관리

- 리액트 외부에서 관리되는 값에 대한 변경을 추적하고, 이를 리렌더링까지 할 수 있는, 페이스북 팀에서 만든 `useSubscription`이 존재
  - 리액트 18에서는 useSubscription 훅이 useSyncExternalStore로 재작성돼 있음


##### Recoil

- Recoil 팀에서는 리액트 18에서 제공되는 동시성 렌더링, 서버 컴포넌트, Streaming SSR 등이 지원되기 전까지는 1.0.0을 릴리스하지 않을 것이라고 밝힌 바 있음

- RecoilRoot
  - Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성
  - Recoil 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장됨
  - 스토어의 상태값에 접근할 수 있는 함수들이 있고, 이 함수를 활용해 상태값에 접근하거나 변경할 수 있음
  - 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알림

- useRecoilValue
  - 외부의 값을 구독해 렌더링을 강제로 일으킨다

- useSetRecoilState
  - 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링을 실행해 최신 atom 값을 가져오게 된다

- 특징
  - 메타 팀에서 주도적으로 개발하고 있기 때문에 다른 라이브러리보다 잘 지원할 것으로 기대됨


##### Jotai

- atom
  - config라는 객체를 반환하고 여기에는
    - 초기값의 init, 가져오는 read, 설정하는 write만 존재
    - 즉 Jotai에서의 atom에 따로 상태를 저장하고 있지 않다

- useAtomValue
  - Recoil과는 다르게, 컴포넌트 루트 레벨에서 Context가 존재하지 않아도 됨
    - Context가 없다면 Provider가 없는 형태로 기본 스토어를 루트에 생성하고 이를 활용해 값을 저장하기 때문

  - store에 atom 객체 그 자체를 키로 활용해 값을 저장 `WeakMap`

- 특징
  - Jotai는 사용자가 키를 관리할 필요가 없음

##### Zustand

- Zustand의 스토어는 스토어가 가지는 클로저를 기반으로 생성됨
  - 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식

- setState는 partial과 replace로 나뉘어져 있음
  - partial은 state의 일부분만 변경하고 싶을 때
  - replace는 state를 완전히 교체하고 싶을 때
    - 이로써 state의 값이 객체일 때 필요에 따라 나눠서 사용할 수 있을 것으로 보인다

- 바닐라 코드는 아무것도 import 하고 있지 않아서, 프레임워크와는 독립적으로 구성돼 있음

- 전체적으로 코드가 매우 간결하다

- 특징
  - 번들링 사이즈가 위 두 개에 비해 작음

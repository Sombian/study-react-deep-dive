# 04장\_서버 사이드 렌더링

## 서버 사이드 렌더링이란?

### 싱글 페이지 애플리케이션

렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식.

첫 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이루어진다.

페이지를 불러온 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리.

최초에 로딩해야 할 자바스크립트 리소스가 커지는 단점

한 번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다는 장점

### 서버 사이드 렌더링

최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식

**싱글 페이지 애플리케이션은 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 담당**

**서버 사이드 방식을 채택하면 렌더링에 필요한 작업을 모두 서버에서 수행**

**장점**

최초 페이지 진입이 비교적 빠르다

검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다

누적 레이아웃 이동이 적다

사용자의 디바이스 성능에 비교적 자유롭다

보안에 좀 더 안전하다

**단점**

소스코드를 작성할 때 항상 서버를 고려해야 한다

적절한 서버가 구축돼 있어야 한다

서비스 지연에 따른 문제

### SPA와 SSR을 모두 알아야 하는 이유

서버 사이드 렌더링 역시 만능은 아니다

- 웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다.
- 설계와 목적, 우선순위에 따라 싱글 페이지 어플리케이션이 더 효율적일 수도 있다.

현대의 서버 사이드 렌더링은 최초 웹사이트 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글페이지 애플리케이션처럼 작동한다.

## 서버 사이드 렌더링을 위한 리액트 API 살펴보기

### r**enderToString**

인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수돠. 서버 사이드 렌더링을 구현하는 데 가장 기초적인 API

최초의 페이지를 HTML로 먼저 렌더링한다고 언급했는데 그 역할은 하는 함수

### **renderToStaticMarkup**

renderToString과 유사하나 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.

리액트의 이벤트 리스너가 필요 없는 완전 순수한 HTML만을 만들 때만 사용된다.

### **renderToNodeStream**

renderToString과 결과물이 완전히 동일하지만 두 가지 차이점이 있다.

- renderToString과 renderToStaticMarkup은 브라우저에서도 실행할 수 있지만 renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능하다. 이는 완전히 Node.js 환경에 의존하고 있기 때문이다.
- renderToString은 이름에서도 알 수 있듯 결과물이 string인 문자열이지만, renderToNodeStream의 결과물은 Node.js의 ReadableStream이다. 이는 utf-8로 인코딩된 바이트 스트림으로, Node.js 환경에서만 사용할 수 있다. 궁극적으로 브라우저가 원하는 결과물, 즉, string을 얻기 위해서는 추가적인 처리가 필요하다.

### **renderToStaticNodeStream**

renderToNodeStream과 제공하는 결과물은 동일하나, renderToStaticMarkup과 마찬가지로 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.

마찬가지로 **hydrate**를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용되는 메서드다.

### **hydrate**

renderToString과 renderToNodeStream 으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.

## **Next.js**

ercel 에서 만든 리액트 기반 서버 사이드 렌더링 프레임워크

### Next.js 시작하기

next/link로 이동하는 경우 서버 사이드 렌더링이 아닌, 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식으로 작동

getServerSideProps 함수가 페이지에 없으면 서버에서 실행하지 않아도 되는 페이지로 처리

### Data Fetching

getStaticPaths, getStaticProps, getServerSideProps, getInitialProps

### 스타일 적용

\_app.tsx에 import로 전역 스타일 적용

module.css 컴포넌트 단위로 적용 가능

scss, sass 가능

css in js 가능

tailwind도 좋다

### **next.config.js**

Next.js 실행에 필요한 설정을 추가할 수 있는 파일이다

# 05장\_리액트와 상태 관리 라이브러리

## **상태 관리는 왜 필요한가?**

상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

### **React 상태관리 역사**

**Flux 패턴의 등장**

양방향 데이터 바인딩의 문제점을 Action -> Dispatcher -> Model -> View 의 단방향흐름으로 데이터를 제어 하는 것

**Redux**

Elm 아키텍처의 영향을 받았다.

보일러플레이트 코드가 너무 많아서 비판을 많이 받았다.

**Context API와 useContext**

Props를 간편하게 넘겨주기 위해 16.3 버전에서 Context API 출시

단점

- 상위 컴포넌트가 렌더링 되면 `shouldComponentUpdate`가 항상 `true`를 반환하여 불필요한 렌더링이 일어난다.
- context를 인수로 받기 때문에 컴포넌트와 결합도가 높다.
- 렌더링을 막아주는 기능이 없다.

## **리액트 훅으로 시작하는 상태 관리**

### **useState와 useReducer**

지역적인 상태관리 방법

### **useState 상태를 바깥으로 분리하기**

리액트 렌더링 원리에 의해 컴포넌트 외부로 값을 빼더라도 "리 렌더링" 트리거를 넣어줘야한다.

### **useState와 Context를 동시에 사용하기**

여러개의 서로 다른 데이터를 공유해 사용하고 싶을 때 사용한다.

### **상태 관리 라이브러리 Recoil, Jotai, Zustand**

**Recoil**

Facebook에서 개발한 React용 상태 관리 라이브러리

React의 훅과 같은 기능을 사용하여 편리한 상태 관리를 제공

atoms와 selectors를 사용하여 상태를 관리

**Jotai**

"minimalist" 상태 관리 라이브러리

Recoil과 유사한 개념을 사용하지만, 더 간단하고 직관적인 API를 제공

React의 Context API에 의존하지 않고도 상태를 전역적으로 관리

**Zustand**

Redux와 같은 전통적인 상태 관리 라이브러리보다 훨씬 적은 설정과 보일러플레이트 코드를 요구

상태를 하나의 저장소(store)에서 관리

작고 간단한 애플리케이션에서 상태 관리를 쉽게하기 위해 설계되었으며, 미들웨어를 사용하여 기능을 확장

# [1회차 06.09.] 1장

# **1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트**

## **1.1 자바스크립트의 동등 비교**

리액트 컴포넌트 렌더링이 일어나는 이유 중 하나가 바로 prop의 동등 비교에 따른 결과다.

객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작동 하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.

리액트의 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

### **1.1.1 자바스크립트의 데이터 타입**

자바스크립트의 데이터 타입은 `원시 타입`과 `객체 타입` 으로 나뉜다.

> **원시 타입**
> 
> - `boolean`
> - `null`
> - `undefined`
> - `string`
> - `number`
> - `symbol`
> - `bigint`
> 
> **객체 타입**
> 
> - `object`

**원시 타입**

객체가 아닌 다른 모든 타입을 의미한다.

**undefined**

- 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지진 않은 인수에 자동으로 할당되는 값

**null**

- 아직 값이 없거나 비어 있는 값을 명시적으로 비어 있음을 표현할 때 사용
- typeof로 확인했을 때 해당 타입이 아닌 ‘object’라는 결과가 반환된다는 것

**Boolean**

- 참(true), 거짓(false)만을 가질 수 있는 데이터 타입
- 조건문에서 true나 false 이외에도 truthy, falsy값이 존재

**Number**

- ECMAScript 표준에 따르면 -(2^53-1)과 2^53-1 사이의 값을 저장할 수 있다.

**Bigint**

- number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나온 것
- number의 한계를 넘어서 더 큰 숫자를 저장할 수 있다.

**String**

- 텍스트 타입의 데이터를 저장하기 위해 사용
- 문자열이 원시 타입이며 변경이 불가능하다
한번 문자열이 생성되면 그 문자열을 변경할 수 없음

Symbol

- ES6에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어 짐

**객체 타입**

- 7가지 원시 타입 이외의 모든 것
즉 자바스크립트를 이루고 있는 대부분의 타입이 객체 타입임
- 배열, 함수, 정규식, 클래스 등이 포함
- 객체 타입은 참조를 전달한다고 해서 참조 타입으로 불림

### **1.1.2 값을 저장하는 방식의 차이**

원시 타입과 객체 타입의 주된 차이점은 값을 저장하는 방식에 있다.
이 차이는 동등 비교 할 때 차이를 만드는 원인이 된다.

원시 타입은 불변 형태의 값으로 저장되며, 변수 할당 시점에 메모리 영영을 차지하고 저장한다

객체 타입은 프로퍼티를 삭제, 추가, 수정할 수 있어 변경 가능한 형태로 저장되며, 값이 아닌 참조를 전달한다.

### **1.1.3 자바스크립트의 또 다른 비교 공식, Object.is**

자바스크립트에서는 비교를 위한 방법으로 Objecrt.is를 제공한다.
Object.is는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드다.

- == vs Object.is
    
    == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변을 한 후에 비교한다.
    
    하지만 Object.is는 이러한 작업을 하지 않아 타입이 다르면 그냥 false다.
    
- **===** vs Object.is
    
    ===과 유사하지만 Object.is가 좀 더 개발자가 기대하는 방식으로 정확하게 비교한다.
    
    ```jsx
    -0 === +0 // true
    Object.is(-0, +0) // false
    
    Number.NaN === NaN // false
    Object.is(Number.NaN, NaN) // true
    
    NaN === 0 / 0 // false
    Object.is(NaN, 0 / 0) // true
    ```
    

주의할 점으로 Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다는 것이다.

### **1.1.4 리액트에서의 동등 비교**

Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행한다.

객체의 얕은 비교만 구현한 이유

- JSX props는 객체이고, props만 일차적으로 비교하면 되기 때문이다.

### 1.1.5 정리

## **1.2 함수**

**1.2.1 함수란 무엇인가?**

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.

### **1.2.2 함수를 정의하는 4가지 방법**

**함수 선언문**

자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식

```jsx
function add(a, b) {
  return a + b;
} 
```

**2. 함수 표현식**

> 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
> 
> 
> 자바스크립트에서 함수는 일급 객체다.
> 

함수는 일급 객체여서 함수를 변수에 할당하는 것이 가능하다.

```jsx
const sum = function (a, b) {
  return a + b;
};

sum(10, 24) // 34 
```

**3. Function 생성자**

함수의 클로저가 생성되지 않아서 권장되지 않은 방식

eval 처럼 실제 코딩에서 사용되지 않은 방법

```
const add = new Function("a", "b", "return a + b");
```

**4. 화살표 함수**

ES6에서 새롭게 추과된 함수 생성 방식

function이라는 키워드 대신 `=>`를 사용해서 편리하다

```jsx
const add = (a, b) => {
  return a + b;
};
 
const add = (a, b) => a + b;
```

앞서 언급한 함수 생성 방식들과의 차이점

constructor를 사용할 수 없다. 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

```jsx
const Car = (name) => {
  this.name = name;
}; 

// TypeError: Car is not a constructor
const myCar = new Car("하이");
```

argument가 존재하지 않는다.

```jsx
function hello() {
  console.log(arguments);
}

// Arguments
hello(1, 2, 3);

const hi = () => {
  console.log(arguments);
};

hi(1, 2, 3);
// ReferenceError: arguments is not defined
```

가장큰 차이점은 this 바인딩이다.

함수 자체의 바인딩을 갖지 않는다.

화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.

### **1.2.3 다양한 함수 살펴보기**

**즉시 실행 함수**

함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.

단 한 번만 호출되고, 다시 호출할 수 없는 함수다.

일반적으로 함수에 이름을 붙이지 않는다.

```jsx
(function (a, b) { 
  return a + b;
})(10, 24); // 34

((a, b) => {
  return a + b;
})(10, 24); // 34
```

글로벌 스코프를 오염시키지 않아 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다

이 함수는 선언과 동시에 즉시 실행되기 때문에 함수 내부의 값은 해당 함수 외부에서 접근할 수 없다

**고차 함수**

함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다.

```jsx
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2,4,6]

// 함수를 반환하는 고차 함수
const add = function (a) {
  // a 가 존재하는 클로저 생성
  return function (b) {
	  // b 를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a + b;
  };
};

add(1)(3); // 4
```

### **1.2.4 함수를 만들 때 주의해야 할 사항**

**함수의 부수효과를 최대한 억제하라**

부수 효과가 없는 함수를 순수 함수라 하고,
부수 효과가 존재하는 함수를 비순수 함수라고 한다.

순수 함수는 항상 동일한 인수를 받으면 동일한 결과를 반환해야하고 외부에 어떠한 영향도 미쳐서는 안 된다.

자바스크립트 함수에서는 가능한 한 부수 효과를 최소화하고, 함수의 실행과 결과를 최대한 예측 가능하도록 설계해야 한다.

**가능한 한 함수를 작게 만들어라**

**누구나 이해할 수 있는 이름을 붙여라**

## **1.3 클래스**

### **1.3.1 클래스란 무엇인가?**

특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것

**constructor**

객체를 생성하는데 사용하는 특수한 메서드, 단 하나만 존재할 수 있으며 여러 개를 사용한다면 에러가 발생

생성자에서 별 다르게 수행할 작업이 없다면 생략도 가능

**프로퍼티**

클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값

**getter와 setter**

getter: 클래스에서 무언가 값을 가져올 때 사용

setter: 클래스 필드에 값을 할당할 때 사용

**인스턴드 메서드**

클래스 내부에 선언한 메서드

prototype에 선언되어 프로토타입 메서드로 불리기도 함

**정적 메서드**

클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드 

this는 사용할 수 없다.

전역 유틸 함수를 정적 메서드로 많이 활용

**상속**

extends 키워드를 활용하면 기본 클래스를 기반으로 다양하게 파생된 클래스를 만들 수 있다.

### **1.3.2 클래스와 함수의 관계**

## **1.4 클로저**

### **1.4.1 클로저의 정의**

MDN에서 정의한 클로저란 함수와 함수가 선언된 어휘적 환경의 조합이라고 돼 있다.

선언된 어휘적 환경이라는 것은, 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다.

호출 되는 방식에 따라 동적으로 결정되는 this와는 다르게
코드가 작성된 순간에 정작으로 결정된다.

클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

### **1.4.2 변수의 유효 범위, 스코프**

변수의 유효 범위를 스코프라고 한다.

**전역 스코프**

전역 레벨에 선언하여 어디서든 호출할 수 있게된다.

브라우저에서 환경 전역 객체는 window
Node.js환경에서는 global

이 객체의 전역 레벨에서 선언한 스코프가 바인딩된다.

```jsx
var global = `global scope`;
 
function hello() {
  console.log(global);
}

console.log(global); // global scope
hello(); // global scope
console.log(global === window.global); // true
```

**함수 스코프**

자바스크립트는 기본적으로 함수 레벨 스코프를 따른다

{ } 블록은 스코프 범위를 결정하지 않고, 자바스크립트에서 스코프는 가장 가까운 스코프에서 변수가 존재하는지 먼저 확인한다

### **1.4.3 클로저의 활용**

변수를 은닉하고, 접근을 제한하며 로그를 남기는 다양한 활용이 가능하다

### **1.4.4 주의할 점**

- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생한다
- 클로저 사용을 적절한 스코프로 가둬두지 않으면 성능에 악영향을 미친다

## **1.5 이벤트 루프와 비동기 통신의 이해**

### **1.5.1 싱글 스레드 자바스크립트**

**프로세스**

- 프로그램을 구동해 프로그램 상태가 메모리상에서 실행되는 작업 단위
- 하나의 프로그램은 하나의 프로세스를 가진다

**스레드**

- 더 작은 실행단위로, 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있다
- 스레드끼리 메모리를 공유할 수 있어, 여러가지 작업을 동시에 수행할 수 있다

### **1.5.2 이벤트 루프란?**

자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

**호출 스택**

- 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택

**이벤트 루프**

- 호출 스택이 비어 있는지 여부를 확인하는 것

### **1.5.3 태스크 큐와 마이크로 태스크 큐**

- 이벤트 루프에는 1개의 마이크로 태스크 큐를 가진다
- 기존의 태스크 큐와는 다른 태스크를 처리한다
- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다
- 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다

> 이벤트 루프는 전체 코드를 실행하고, 호출 스택이 비었을 때 다음과 같은 순서로 작업을 수행한다
> 
> 
> 마이크로 태스크 큐 → 렌더링 → 태스크 큐
> 

## **1.6 리액트에서 자주 사용하는 자바스크립트 문법**

### **1.6.1 구조 분해 할당**

배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것을 의미한다.

배열과 걕체에서 사용하며, 주로 어떠한 객체나 배열에서 선언문 없이 즉시 분해해 변수를 선언하고 할당하고 싶을 때 사용한다.

**배열 구조분해 할당**

자유롭게 이름을 선언할 수 있다

`,` 의 위치에 따라 값이 결정되기 때문에 중간 인덱스 값을 생략할 수 있다

```jsx
const arr = [1, 2, 3, 4, 5];
const [firts, , , , fifth] = arr;
다;
 
first; // 1
fifth; // 5
```

기본값을 선언할 수가 있다. 다만 값이 `undefined`일 때만 기본값을 사용된다

특정 값 이후의 값을 다시 배열로 선언하고 싶으면 전개 연산자를 사용할 수 있다. 다만 뒤쪽에서만 사용 가능하다

**객체 구조분해 할당**

객체에서 값을 꺼내온 뒤에 할당하는 것을 의미한다.

- 배열 구조 분해 할당과 달리, 객체 내부 이름으로 꺼내온다
- 새로운 이름으로 다시 할당이 가능하다
- 기본값을 설정할 수 있다
- 전개 연산자를 사용할 수 있다

### **1.6.2 전개 구문**

배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문이다.

**배열의 전개 구문**

- 전개 구문을 활요하면 매우 쉽게 배열을 합성할 수 있다.
- 배열 내부에서 `...배열`을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고, 이를 내부 배열에서 활용할 수 있다
- 이러한 특징을 활용하면 기존 배열에 영향을 미치지 않고 배열을 복사할 수 있다

**객체의 전개 구문**

- 배열과 비슷하게 사용이 가능하다
- 객체 전개 구문은 순서가 중요하다
- 객체를 합성하는 데 있어 편리함을 가져다 준다

### **1.6.3 객체 초기자**

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```jsx
const a = 1;
const b = 2;

const obj = { a, b }; 
console.log(obj); // { a: 1, b: 2 }
```

### **1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach**

- map 메서드는 배열의 각 원소에 대해 특정 작업을 수행한 후, 그 결과를 새로운 배열에 담아서 반환
- filter 메서드는 배열의 각 원소에 대해 특정 조건을 만족하는 원소만을 따로 추출하여 새로운 배열에 담아서 반환
- reduce 메서드는 배열의 각 원소에 대해 특정 작업을 수행한 후, 그 결과를 새로운 배열에 담아서 반환
- forEach 메서드는 콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행한다
forEach 메서드 주의점
반환 값이 없다
실행 되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 이르 멈출 수 없다

### **1.6.5 삼항 조건 연산자**

- 삼항 조건 연산자(ternary operator)는 조건문의 축약형
- 삼항 조건 연산자는 조건문의 결과에 따라 반환할 값을 결정

```jsx
// 조건문 ? 참일 때 값 : 거짓일 때 값
const result = 10 % 2 === 0 '짝수' : '홀수';
// 짝수
```

## **1.7 선택이 아닌 필수, 타입스크립트**

동적 언어인 자바스크립트에서 런타임에만 타입을 체크할 수 있는 한계를 극복해 코드를 더욱 안전하게 작성하면서 버그를 줄일 수 있다

### **1.7.1 타입스크립트란?**

타입스크립트는 기존 자바스크립트 문법에 타입을 추가한 것으로, 런타임에서만 확인할 수 있는 자바스크립트의 문제점을 보완한다

### **1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법**

**any 대신 unknown을 사용하자**

any는 모든 타입을 허용하는 데 반해, unknown은 불확실한 타입을 나타내며 명시적인 타입 체크가 필요한 경우 사용

**타입 가드를 적극 활용하자**

instanceof: 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자

typeof: 특정 요소에 대해 자료형을 확인하는 데 사용

in: 어떤 객체에 키가 존재하는지 확인하는 용도

**제네릭**

함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구다

**인덱스 시그니처**

- 객체의 키를 정의하는 방식

인덱스 시그니처를 사용하면 동적인 객체를 생성할 수 있지만, 타입이 넓어져서 특정 키에 대한 타입 체크가 이루어지지 않아 2번 케이스처럼 예상치 못 한 에러가 발생할 수 있다. 이러한 이유로 타입스크립트에서는 가능하면 인덱스 시그니처를 사용하기보다는 명시적인 속성을 선언하는 것이 권장된다

### **1.7.3 타입스크립트 전환 가이드**

**tsconfig.json 먼저 작성하기**

**JSDoc과 @ts-check를 활용해 점진적으로 전환하기**

**타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기**

**파일 단위로 조금씩 전환하기**

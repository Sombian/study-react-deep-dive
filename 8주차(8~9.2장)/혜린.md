# 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

### 8.1 ESLint를 활용한 정적 코드 분석

##### 8.1.1 ESLint 살펴보기

ESLint가 코드를 분석하는 방법은 아래와 같다.

1. 자바스크립트 코드를 문자열로 읽는다.
2. 자바스크립트 코드를 분석할 수 있는 parser로 코드를 구조화한다.
3. 2번에서 구조화 한 트리를 AST(Asbstract Synatx Tree)라 하며, 이 트리를 기준으로 각종 규칙과 대조한다.
4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나 수정한다.

ESLint의 기본 parser는 `espree` 이다. 분석 결과를 바탕으로 코드가 잘못 됬는지, 어떻게 수정해야하는지 판단해야 하는데 이것을 `규칙(Rules)` 이라고 한다. 이 특정한 규칙의 모음을 `plugins`라고 한다.

##### 8.1.2 eslint-plugin과 eslint-config

eslint-plugin 접두사의 패키지는 규칙을 모아놓은 패키지, eslint-config 접두사의 패키지는 eslint-plugin을 한데 묶어서 완벽하게 한 세트로 제공하는 패키지 이다.
일반적으로 eslint-config 를 설치해서 당장 사용한다.

##### 8.1.3 나만의 ESLint 규칙 만들기

조직 내 규칙이나 코드 변화로 인해 일괄적으로 고쳐야하는 경우, ESLint 규칙을 생성해서 효율적으로 고칠 수 있다. 규칙은 하나씩 만들어 배포하는 것은 불가능하며, 반드시 eslint-plugin 형태로 규칙을 묶음으로 배포하는 것만 가능하다.

##### 8.1.4 주의할 점

#### Prettier와 충돌

ESLint가 잠재적인 코드 문제를 분석해 준다면, Prettier는 코드 포맷팅과 관련된 작업을 하는 툴이다. 해결 방법은 아래와 같다.

- 서로 규칙이 충돌되지 않게 규칙을 잘 선언한다.
- 자바스크립트나 타입스크립트는 ESLint에 그외 파일을 Prettier에 맡긴다.

#### react-hooks/no-exhaustive-deps

useEffect나 useMemo 같은 훅의 의존성 배열을 제대로 선언했는지 확인하는 역할을 한다. 총 1,800여줄로 구성되어 있는 규칙이다. 이 규칙을 무시하는것은 대부분 위험한 발상이다.

- **괜찮다고 임의로 판단한 경우,** 의도치 않은 곳에서 잠재적인 버그를 야기할 수 있다.
- **의존성 배열이 너무 긴 경우,** 함수 내부가 너무 길다는 말을 의미한다. 함수를 쪼개 가독성과 안정성을 확보해야한다.
- **마운트 시점에 한 번만 실행하고 싶은 경우,** 상태와 관계없이 한번만 실행해야 하는 것이 있다면 컴포넌트에 존재해야 할 이유가 없다. 적절한 위치로 옮겨서 사용하자

#### ESLint 버전 충돌

이런 문제로 인해 ESLint 공식문서에서는 ESLint를 peerDependencies로 설정해두라고 말하고 있다.

### 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

백엔드와 테스트 방법론이 사뭇 다르다. 백엔드는 화이트박스 테스트를 주로 하며, 프론트엔드는 블랙박스 테스트를 주로 한다. 유저의 인터렉션을 최대한 예측해서 확인을 해야하며 단순 함수부터 사용자의 동작을 흉내내는 테스트 등 여러 테스트가 있다.

##### 8.2.1. React Testing Library

Dom Testing Library를 기반으로 만들어졌다. 브라우저에서 실행시키지 않아도 Node에서 DOM을 불러오고 조작할 수 있다.

##### 8.2.2. 자바스크립트 테스트의 기초

기본적인 테스트 방식은 아래와 같은 방식을 거친다.

1. 테스트할 함수나 모듈을 선정한다
2. 함수나 모듈이 반환하길 기대하는 값을 만든다.
3. 함수나 모듈의 실제 반환값을 적는다.
4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다.
5. 기대값과 같으면 성공 다르면 실패를 반환한다.

이런 테스트 결과를 확인할 수 있게 도와주는 라이브러리를 `어설션(assertion)`이라 하며, 테스팅 프레임워크들은 이를 기반으로 테스트를 수행한다.

### 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

리액트 컴포넌트 테스트는 다음과 같은 순서로 진행된다.

1. 컴포넌트를 렌더링한다.
2. 필요하다면 컴포넌트의 특정 액션을 수행한다.
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과 실제를 비교한다.

리액트 컴포넌트가하는 일반적인 시나리오는 특정한 무언가를 지난 HTML 요소가 있는지 여부다. 이를 확인하는 방법은 크게 아래와 같이 3가지 정도가 있다.

- **getBy,** 인수의 조건에 맞는 요소 반환.
- **findBy,** getBy와 유사하나 차이점은 Promise를 반환. 즉 비동기로 찾는다.
- **queryBy,** 인수 조건에 맞는 요소를 반환하고, 찾지 못하면 null 반환

#### 데이터셋

HTML의 특정 요소와 관련된 임의 정보를 추가할 수 있는 HTML 속성. `data-testid` 같은 속성을 추가하여 유용하게 사용할 수 있다.

#### 동적 컴포넌트

useState 등의 통해 상태변경도 같이 일어나는 컴포넌트의 경우이다.

- userEvent.type, 사용자가 타이핑을 하는 것을 흉내내는 메소드. fireEvent를 순차적으로 실행한다.

#### 비동기 컴포넌트

MSW를 사용해 해결해보자!

##### 8.2.4 사용자 정의 훅 테스트하기

사용자 정의 훅도 동일하게 테스트 가능하다. 훅을 렌더링 하기 위해서는 `renderHook`을 사용해야 한다. initialProps를 지정하여 renderHook의 함수 초기값을 지정할 수 있다.

##### 8.2.5 테스트를 작성하기에 앞서 고려해야할 점

테스트 커버리지는 만능이 아니다. 테스트 코드를 작성하기 전 가장 중요한 부분은 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것 이다. 가장 핵심인 부분부터 하나씩 작성해 나가는게 중요하다.

##### 8.2.6 그 밖의 해볼만한 여러 가지 테스트

- 유닛테스트
- 통합 테스트
- E2E 테스트
  E2E 테스트는 Cypress 같은 외부 라이브러리의 힘을 빌려야 한다.

##### 8.2.7 정리

테스트가 이뤄야할 목표는 애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것 하나이다.

# 9장 모던 리액트 개발 도구로 개발 및 배포환경 구축하기

### 9.1 Next.js로 리액트 개발 환경 구축하기

`create-react-app` 과 `create-next-app`은 리액트와 Next.js 애플리케이션을 손쉽게 만들 수 있는 CLI 도구 이다.

```생각 & 의견
실제 https://react.dev/learn/start-a-new-react-project 보시면 create-react-app 관련 내용이 삭제 되어있었습니다. 한때 깃헙 이슈에서 난리가 났었는데 vite을 뉴노멀로 만들자 parcel 도입하자 등 이야기가 꽤 많았는데 그 이슈를 못찾겠네요..
```

##### 9.1.1 create-next-app 없이 하나씩 구축하기

Pass

##### 9.1.2 tsconfig.json 작성하기

- `$schema`는 해당 JSON 파일이 무엇을 의미하지는, 어떤키와 어떤값이 들어갈 수 있는지 알려주는 도구이다.

#### compilerOptions

타입스크립트를 자바스크립트로 컴파일 하는 경우 사용하는 옵션이다.

- target: 타입스크립트가 변환을 목표로 하는 언어의 버전
- lib: 변환과 다르게 사용 가능한 버전
- skipLibCheck: .d.ts파일 검사 여부

```생각 & 의견
저는 켜놓는 편 입니다. .d.ts 파일을 생각보다 많이 사용해서 타입체크가 안되면 많이 불편하더라고요
```

- strict: 엄격 모드
- noImplicitAny: 변수에 any 자동할당 비활성화
- noEmit: 컴파일하지 않고 타입만 체크. Next.js에서는 SWC가 컴파일함
- esModuleInterop: CJS 방식의 모듈을 import 할 수 있게 허용
- jsx: .tsx 파일 내부에 있는 JSX를 어떻게 컴파일 할지 설정
  - react: 기본값, React.CreateElement로 변환된다. 16까지의 기본값
  - react-jsx: 17에서 등장, react/jsx-runtime을 사용하여 변환. 이 방식을 사용하면 상단에 `import React from 'react`를 적지 않아도 됨
  - react-jxdev: react-jsx와 동일하지만 디버깅 정보 추가
  - preserve: 변환하지 않고 그대로 유지
  - react-native: react-native에서 사용하는 방식, 변환하지 않고 그대로 유지

##### 9.1.3 next.config.js 작성하기

pass

##### 9.1.4 ESLint와 Prettier 설정하기

eslint-config-next로는 부족하다. @titicaca/eslint-triple을 설치하면 코드 스타일링등 일반적인 작업을 처리해준다. `.next`나 `node_modules`은 정적파일 분석에 필요없음으로 제외하자!

```생각 & 의견
@titicaca/eslint-triple 라이브러리 보니까 트리플이라는 회사의 config인 것 같네요
https://github.com/titicacadev/triple-config-kit
```

##### 9.1.5 스타일 설정

styled-component를 사용한다면 next.config.js에 styledComponent 옵션을 true로 바꿔주어 SWC에게 styled-component를 사용한다는 것을 알려주자.

```생각 & 의견
emotion도 있어요!
```

##### 9.1.6 애플리케이션 코드 작성

Next.js 애플리케이션 코드는 `src/page`아래 실제 라우팅과 관련된 파일을 기재해야 한다. 폴더 구조에 정답은 없다. 팀에서 잘 정해서 최선의 구조를 사용하자

##### 9.1.7 정리

이런 프로젝트를 매번 만드는것은 귀찮기 때문에 Gituhb의 template이나 CLI로 만들어서 사용해보자

### 9.2 깃허브 100% 사용하기

1억개가 넘는 공개 저장소가 있으며, 어느 회사나 조직을 가더라도 깃허브를 쓰는게 사실상 표준인 널리 사랑받는 서비스이다.

##### 9.2.1 깃허브 액션으로 CI 환경 구축하기

CI란, 여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정을 말한다. 깃허브 액션에서 자주나오는 기본 개념은 아래와 같다.

- 러너(runner): 깃허브 액션이 실행되는 서버를 말한다.
- 액션(action): 러너에서 실행되는 액션의 단위를 의미한다.
- 이벤트(event): 액션을 일으키는 이벤트를 의미한다. pull_requsest, issues 등이 있다.
- 잡(jobs): 하나의 러너에서 실행 되는 여러 스텝의 모음을 의미한다.
- 스탭(steps): 잡 내부에서 일어나는 하나하나의 작업을 의미한다.

액션을 작성하려면 저장소 루트의 `.github/workflows` 폴더를 생성하고 내부에 `.yml` 또는 `.yaml`로 파일을 작성하면 된다.

#### 브랜치 보호 규칙

머지하기전에 꼭 성공해야 하는 규칙이 있다면 저장소의 Branch 옵션의 `Add branch protection rule`을 클릭해 브랜치 보호 규칙을 추가해보자.

##### 9.2.2 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기

#### 깃허브 제공 기본 액션

- actions/checkout: 깃허브 저장소를 체크아웃 하는 액션
- actions/setup-node: Node.js를 설치하는 액션
- actions/github-scripts: Github가 제공하는 API를 사용할 수 있게 해주는 액션
- actions/stale: 오래된 이슈나 PR을 자동으로 닫거나 해주는 액션
- actions/dependency-review-action: 의존성 그래프, 즉 package.json 등의 내용이 변경 되었을 때 실행되는 액션.
- actions/codeql-action: 깃허브 코드 분석 솔루션인 code-ql을 활용해 저장소 내 취약점을 분석해준다.

#### lirantal/is-website-vulnerable

특정 웹사이트에 방문하여 해당 웹사이트 라이브러리에 취약점이 존재하는 지확인 하는 깃허브 액션. 취약점이 포함된 패키지는 배포가 안되게 하는게 좋지만 혹시 모르니 주기적으로 검사하는 것이 좋다. 배포 액션의 잡 중에 needs: \*\*\* 구문을 추가해 배포 잡이 끝난 후에 실행 시키거나, 별도의 액션을 추가하여 on.workdlow_run으로 실행 하는 방법도 있다.

#### Lighthous CI

구글에서 제공하는 액션으로 웹 성능 지표인 라이트하우스를 CI 기반으로 실행할 수 있도록 도와 주는 도구다.

##### 9.2.3 깃허브 Dependabot으로 보안 취약점 해결하기

깃허브에서 제공하는 강력한 기능 중 하나로, 문제 발생 시 PR까지 열어준다.

#### 버전

주.부.수 형태로 관리한다. npm 버전의 규칙은 아래와 같다

- react@16.0.0: 정확히 해당 버전에만 의존한다
- react@^16.0.0: 0보다 높은 부버전에 대해서는 호환된다라는 가정하에 설치 가능하다. 주 버전이 0 인경우, 부 버전이 올라가도 변경이 있을 수 있음으로 수 버전까지만 수용
- react@~16.0.0: 패치(수) 버전에 대해서만 호환된다라는 것을 의미한다.

#### 의존성

패키지를 구분하는 것에 의문을 제기하는 목소리가 있다.

- 번들러로 인해 devDepdencies, dependencies 상관없음
- 개발 파이프라인이 복잡해졌다.
  하지만, npm에 업로드 할 패키지를 개발한다면 중요해진다.

Dependabot은 Critical, Hight, Moderate, Low 4단계로 나눈다.

```sh
npm list
```

명령어를 통해 취약점이 발견된 패키지를 찾을 수 있다. PR이 열린 경우 머지를 해서 해결할 수 있다. 반대로 PR이 생성되지 않았을 경우는 직접 버전을 업데이트 한다. 이런 문제를 해결할 수 있는 가장 좋은 방법은 의존성을 가장 적게 유지하는 것이다.

##### 9.2.4 정리

깃허브만 잘 활용해도 코드 관리에 필요한 거의 대부분의 기능을 이용할 수 있다. 꾸준히 코드를 작성할 예정이라면 프로계정을 사용보자!

# [8회차 07.28.] 8, 9.2장

# 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

## 8.1 ESLint를 활용한 정적 코드 분석

### 8.1.1 ESLint 살펴보기

- ESLint는 어떻게 코드를 분석할까?
    - 자바스크립트 코드를 문자열로 읽는다.
    - 자바스크립트 코드를 분석할 수 있는 파서로 코드를 구조화한다.
    - 2번에서 구조화한 트리를 AST라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.
    - 규칙과 대조했을 때 이를 위반한 코드를 알리거나 수정한다.

### 8.1.2 eslint-plugin과 eslint-config

- eslint-plugin
    - lint 규칙들을 모아놓은 패키지
- eslint-config
    - eslint-plugin을 묶어서 완벽하게 한 세트로 제공하는 패키지
    - IT 기업들에서 공개한 잘 만들어진 eslint-config
        - eslint-config-airbnb
        - @titicaca/triple-config-kit
        - eslint-config-next

### 8.1.3 나만의 ESLint 규칙 만들기

- 이미 존재하는 규칙을 커스터마이징해서 적용하기
- 완전히 새로운 규칙 만들기

### 8.1.4 주의할 점

- Prettier와의 충돌
    - 코드 포매팅 도구인 Prettier와 비슷한 기능도 ESLint가 제공하기 때문에 충돌이 발생할 수 있다.
    - ESLint 에서 코드 포매팅에 관련된 규칙을 끄는 것으로 해결이 가능하다.
- 규칙에 대한 예외 처리, 그리고 react-hooks/no-exhaustive-deps
    - useEffect와 useMemo에서 의존성 배열이 필요할 때, 위 규칙을 끄는 경우가 있다.
    - 하지만 위험한 발상이며, 잠재적인 버그를 야기할 수 있다.
    - 의존성 배열이 없어도 되는 경우라면 컴포넌트의 상태와 별개로 동작하기 때문에 선언 위치를 다시 고민해 보자.
    - 의존성 배열이 너무 긴 경우라면 useEffect 내부 함수 내용이 너무 길다는 것과 동일하다. 함수를 쪼개자.
    - 마운트 시점에 한번만 실행하고 싶은 경우라면 `[]`로 의존성 배열을 작성하곤 한다. 이 방법은 클래스형 접근방법이고 함수형에는 맞지 않을 수 있다.
- ESLint 버전 충돌

## 8.2 리액트 팀이 권장하는 리액트 테스트 라이브러리

- 프론트엔드 테스트는 일반적인 사용자와 동일하거나 유사한 환경에서 수행
    - 사용자가 프로그램에서 수행하는 주요 비즈니스 로직이나 모든 경우의 수를 고려

### 8.2.1 React Testing Library란?

- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리

### 8.2.2 자바스크립트 테스트의 기초

- 테스트할 함수나 모듈을 선정한다.
- 함수나 모듈이 반환하길 기대하는 값을 적는다.
- 함수나 모듈의 실제 반환 값을 적는다.
- 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다.
- 기대하는 결과를 반환한다면 테스트는 성공이며, 만약 기대와 다른 결과를 반환하면 에러를 던진다.

### 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

- 정적 컴포넌트
- 동적 컴포넌트
- 비동기 이벤트가 발생하는 컴포넌트

### 8.2.4 사용자 정의 훅 테스트하기

- react-hooks-testing-library
- renderHook

### 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

- 프론트엔드 테스트는 커버리지가 100%라고 하더라도 유저의 입력이 자유롭기 때문에 모든 상황을 커버하기 어렵다.
- 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것이 가장 중요

### 8.2.6 그 밖에 해볼 만한 여러가지 테스트

- 유닛 테스트
- 통합 테스트
- 엔드 투 엔드 테스트

### 8.2.7 정리

- 결국 테스트의 목표는 애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것

---

# 9장 모던 리액트 개발 도구로 개발 및 배포환경 구축하기

## 9.1 Next.js로 리액트 개발 환경 구축하기

### 9.1.1 create-next-app 없이 하나씩 구축하기

### 9.1.2 tsconfig.json 작성하기

- `$schema`는 해당 JSON 파일이 무엇을 의미하지는, 어떤 키와 어떤 값이 들어갈 수 있는지 알려주는 도구이다.
    
    **compilerOptions :**
    타입스크립트를 자바스크립트로 컴파일 하는 경우 사용하는 옵션이다.
    

### 9.1.3 next.config.js 작성하기

### 9.1.4 ESLint와 Prettier 설정하기

### 9.1.5 스타일 설정

### 9.1.6 애플리케이션 코드 작성

### 9.1.7 정리

## 9.2 깃허브 100% 사용하기

### 9.2.1 깃허브 액션으로 CI 환경 구축하기

- **CI란**
    - 저장소에서 코드의 변화가 있을 때마다 전체 소프트웨어의 정합성을 확인하기 위한 테스트, 빌드, 정적 분석, 보안 취약점 분석과 같은 작업을 자동으로 실행
    - 깃허브 액션: 깃허브 저장소를 기반으로 깃허브에서 발생하는 이벤트를 기반으로 다양한 작업 수행
        - 어떤 브랜치에 푸시가 발생하면 빌드를 수행
        - 특정 브랜치가 메인 브랜치를 대상으로 풀 리퀘스트를 열리면 빌드, 테스트, 정적 분석을 수행

**깃허브 액션의 기본 개념**

- 러너(runner): 파일로 작성된 깃허브 액션이 실행되는 서버
- 액션(action): 러너에서 실행되는 하나의 작업 단위
- 이벤트(event): 깃허브 액션의 실행을 일으키는 이벤트
    - pull_request, issues, push, schedule 등
- 잡(jobs): 하나의 러너에서 실행되는 여러 스텝의 모음
- 스텝(steps): 잡 내부에서 일어나는 각각의 작업
- 스텝들을 엮어서 잡을 만들고, 여러 개의 잡은 병렬로 실행되며, 잡을 하나 이상 모아둔 것을 액션이라고 한다. 액션을 실행하는 것이 러너다.

**깃허브 액션 작성하기**

- 액션을 작성하려면 저장소 루트의 .github/workflows 폴더를 생성하고 내부에 .yml 또는 .yaml로 파일을 작성하면 된다.

### 9.2.2 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기

**깃허브 제공 기본 액션**

- actions/checkout: 깃허브 저장소를 체크아웃 하는 액션
- actions/setup-node: Node.js를 설치하는 액션
- actions/github-scripts: Github가 제공하는 API를 사용할 수 있게 해주는 액션
- actions/stale: 오래된 이슈나 PR을 자동으로 닫거나 해주는 액션
- actions/dependency-review-action: 의존성 그래프, 즉 package.json 등의 내용이 변경 되었을 때 실행되는 액션.
- actions/codeql-action: 깃허브 코드 분석 솔루션인 code-ql을 활용해 저장소 내 취약점을 분석해준다.

**calibreapp/images-actions**

- 저장소에 포함돼 있는 이미지를 최적화하는 액션
- PR로 올라온 이미지(jpb, jpeg, png 등)을 sharp 패키지를 이용해 거의 무손실로 압축해 다시 커밋

**lirantal/is-website-vulnerable**

- 특정 웹사이트를 방문해 해당 웹사이트에 라이브러리 취약점이 존재하는지 확인하는 액션

**Lighthous CI**

- 웹 성능 지표인 라이트하우스를 CI 기반으로 실행할 수 있도록 도와주는 도구
- 프로젝트의 URL을 방문해 라이트하우스 검사를 실행해 웹사이트의 성능 지표를 측정

### 9.2.3 깃허브 Dependabot으로 보안 취약점 해결하기

- 의존성에 문제가 있을 경우 문제를 알려주고 가능하다면 해결할 수 있는 풀 리퀘스트를 열어준다.

**package.json의 dependencies 이해하기**

- 버전
    - **주.부.수** 로 구성돼 있다.
        1. 주 버전: 기존 버전과 호환되지 않게 API가 변경되는 경우
        2. 부 버전: 기존 버전과 호환되면서 새로운 기능 추가
        3. 수 버전: 기존 버전과 호환되면서 버그 수정
    - 유의할 점
        - 특정 버전으로 패키지를 배포하고 나면 그 버전의 내용은 절대 변경하지 않는다. 변경 사항이 있다면 반드시 새로운 버전으로 배포한다.
- 의존성
    - pacakge.json에서 dependencies는 npm 프로젝트를 운영하는 데 필요한 자신 외의 npm 라이브러리를 정의해 둔 JSON 형식의 목록

**Dependabot으로 취약점 해결하기**

- Dependabot은 Critical, Hight, Moderate, Low 4단계로 나눈다.

### 9.2.4 정리

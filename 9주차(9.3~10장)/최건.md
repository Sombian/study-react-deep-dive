# 9.3장

## 배포

다음은 리액트 애플리케이션을 가장 손쉽고 빠르게 배포할 수 있도록 도와주는 3가지 SaaS 서비스이다.

1. Netlify
2. Vercel
3. DigitalOcean

# 9.4장

## 도커

도커는 애플리케이션을 빠르게 배포할 수 있도록 독립된 환경에서 항상 일관되게 실행할 수 있는 '컨테이너'를 제공한다.

# 10장

## 리액트 17 ~ 18 변경 사항

### 점진적 업그레이드

리액트는 유의적 버전(semantic version)을 기반으로 업데이트를 거치고 있었다. 즉, 새로운 major 버전이 출시되면, 이전 버전의 API 제공을 완전히 중단해 버리는 방식을 채택했다. 이러한 전략은 레거시 코드의 버전업을 기피하게 하는 주된 원인이었었기에 리액트 17에서는 점진적인 버전업을 제공한다. 즉, 기존의 코드를 유지하면서 새로운 major 버전의 일부 기능만을 사용할 수 있다.

### 이벤트 위임 방식의 변경

리액트는 최초 출시부터 이벤트 위임을 적극적으로 사용해오고 있다. 리액트 16까지는 이벤트 위임이 전부 document에서 수행되고있었지만, 17부터는 루트 요소에서 수행된다. 이를 통해 이벤트 버블링으로 인한 혼선을 방지할 수 있게되었다.

### JSX Transform

JSX는 브라우저가 이해할 수 있는 코드가 아니기에 JS로 변환하는 과정이 반드시 필요하다. 이러한 JSX변환을 사용하기 위해 직접 React를 사용하는 구문이 없더라도 반드시 `import React from "react"`가 필요했었지만 리액트 17부터는 import 없이도 JSX를 변환할 수 있도록 개선되었다.

### 이벤트 풀링

리액트에는 브라우저의 기본 이벤트의 wrapper인 SyntheticEvent라는 객체가 존재한다. 이 과정에서 오버헤드가 발생하기에 SyntheticEvent 풀(Pool)을 만들어서 이벤트가 발생할 때마다 객체의 참조를 가져오는 과정을 거쳤다.

**이벤트 풀링 과정**
1. 이벤트 핸들러가 이벤트를 발생시킨다
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다
3. 이벤트 정보를 합성 이벤트 객체에 전달한다
4. 이벤트 리스너가 실행된다
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다

이처럼 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화된다. 따라서 비동기 코드 내부에서 이벤트 객체에 접근하면 null값을 얻게된다. 이를 해결하기 위해 event.persist() 같은 처리가 필요했었다.

```tsx
function handle(event: React.ChangeEvent)
{
	event.persist();

	setValue(() => event.target.value);
}
```

이 같은 방식이 성능 향상에 크게 영향을 끼치지 못하고, 동기/비동기 코드간에 일관성이 없다는 문제들로 인해 리액트 17에서는 이벤트 풀링이 삭제되었다.

### 클린업 함수의 비동기 실행

리액트 16까지는 useEffect 내부의 클린업 함수가 동기적으로 실행되었으며, 따라서 클린업 함수가 완료되기 전까지 다른 작업들을 중지(Blocking)시켰었다. 따라서 리액트 17에서는 렌더링이 끝난 이후에 클린업 함수를 비동기적으로 실행하도록 변경되었다.

### undefined 반환에 대한 일관적인 처리

리액트는 컴포넌트 내부에서 undefined를 반환하면 오류를 발생시킨다. 이는 의도치 않은 반환값으로 인한 실수를 방지하기 위해서였다. 그러나 리액트 16까지는 forwardRef 또는 memo에서 undefined를 반환하는 경우에는 별다른 오류를 출력하지 않았었다. 리액트 17부터는 일관성있게 오류가 정상적으로 발생하며, 18부터는 undefined를 반환해도 오류가 발생하지 않는다.

### useId

컴포넌트별로 고유한 값을 생성하는 훅이다. 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때에도 서버와 클라이언트에서 동일한 값을 가지도록 설정해준다.

### useTransition

동기 작업으로 인해 UI 변경을 늦추지 않고 상태를 변경할 수 있는 훅이다. useTrantision은 리액트 18의 변경 사항의 핵심 중 하나인 동시성(concurrency)을 다룰 수 있다.

### useDeferredValue

리렌더링이 급하지 않은 부분을 지연할 수 있도록 도와주는 훅이다. 특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷하지만, useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 작업을 수행한다.

### useSyncExternalStore

과거 리액트에서는 렌더링을 동기적으로 일괄로 처리했기에 동시성 문제가 없었다. 그러나 리액트 18부터는 렌더링이 비동기적으로 실행되기에 동시성 문제가 발생할 수 있다. state 같은 경우 useTransition, useDeferredValue 등의 훅을 사용해 이러한 문제를 해결할 수 있지만 리액트에서 관리할 수 없는 외부 값(e.g. document.body, window.innerWidth)의 경우에는 그렇지 못하다. useSyncExternalStore는 외부 값에 의존하는 경우의 동시성 문제를 해결해주는 훅이다.

### useInsertionEffect

useSyncExternalStore가 상태 관리 라이브러리를 위한 훅이라면, useInsertionEffect는 CSS-in-JS 라이브러리를 위한 훅이다. useInsertionEffect의 기본적인 구조는 useEffect와 동일하지만, 실행 시점이 다르다. useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행된다. 즉, useInsertionEffect -> useLayoutEffect -> useEffect 순으로 실행된다.

### 자동 배치(Automatic Batching)

자동 배칭은 여러 상태 변경을 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법이다. 리액트 17까지는 이벤트 핸들러 내부에서는 자동 배치 작업이 이루어지고 있었지만 Promise, setTimeout 같은 비동기 이벤트에서는 자동 배치가 이루어지지 않았다. 즉, 동기와 비동기 작업간에 일관성이 없었기에 리액트 18부터는 모든 작업에 자동 배치가 적용된다. 만약 이러한 자동 배치를 사용하고 싶지 않은 경우 flushSync를 사용할 수 있다.

### 더욱 엄격해진 엄격 모드

엄격 모드는 컴포넌트 형태로 선언해서 사용할 수 있으며, 다음의 것들을 사용할 시 경고를 띄운다.

- 클래스 컴포넌트에서 사용되는 생명주기 메소드 중 일부인 componentWillMount, componentWillReceiveProps, componentWillUpdate는 더이상 사용할 수 없게 되었다.

- 과거 컴포넌트 내부에서 문자열로 ref를 생성하고, 이를 사용해 DOM 노드를 참조하는 것이 가능했다. 그러나 해당 방식은 문제가 있었기에 이후에 사용이 금지되었다.

- findDOMNode는 ref가 없었던 당시 컴포넌트 내부의 특정 요소를 가져올 수 있도록 제공되는 메소드였다. 그러나 해당 방식은 하드코딩의 성격이 짙었고, 특히 ref가 등장하면서 더이상 사용하지 않게되었다.

또한 엄격 모드는 각종 생명주기 메소드 및 함수형 컴포넌트의 경우 훅을 의도적으로 이중으로 호출시켜 컴포넌트가 순수한지 여부를 파악한다.

### Suspense 기능 강화

Suspense는 리액트 16.3부터 추가된 기능으로, 컴포넌트를 동적으로, 그리고 비동기적으로 가져올 수 있게 해준다. 다만 초창기에는 문제가 다소 있었는데, 대표적으로 Suspense 내부의 컴포넌트가 전부 불러오기도 전에 useEffect가 실행되었었고 서버 사이드에서 실행이 불가능했었다. 리액트 18부터는 Suspense 컴포넌트가 실험 단계를 벗어나 정식으로 지원며 서술한 문제를 포함해 다른 불편함도 수정되었다.

### 폴리필 제거

리액트 18부터는 최신 JS 기능(Promise, Symbol, Object.assign)들을 사용할 수 있다는 가정하에 배포된다. 따라서 이러한 기능을 지원하지 않는 브라우저에서 서비스를 제공해야한다면 폴리필을 반드시 추가해야한다.

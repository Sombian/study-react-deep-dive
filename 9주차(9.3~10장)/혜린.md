# 10장 리액트 17과 18의 변경 사항 살펴보기

## 10.1 리액트 17버전 살펴보기

### 10.1.2 이벤트 위임 방식의 변경

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라고 한다.

이벤트 단계는 아래와 같다.

1. 캡쳐: 이벤트 핸들러가 트리 최상한 요소에서부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미한다.
2. 타깃: 이벤트 핸들러가 타깃 노드에 도달하는 단계다. 이 단계에서 이벤트가 호출된다.
3. 버블링: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다.

이벤트 위임이란 이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.

리액트 17부터는 이벤트 위임이 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다. 

ex. 버블링으로 인한 혼선을 방지하기 위해서

따라서 만약 코드에 document.addEventListener를 활용해 리액트의 모든 이벤트를 documnet에서 확인하는 코드가 있다면 여기까지 이벤트가 전파되지 않는 경우도 존재할 수 있으므로 확인해야 한다.

### 10.1.3 import React from ‘react’가 더 이상 필요없다: 새로운 JSX transform

리액트 17부터 바벨과 협력해 import React from ‘react’ 구문 없이도 JSX를 변환할 수 있게 됐다.

따라서 불필요하게 import React를 작성하지 않아도 되며, 번들링 크기도 약간 줄일 수 있다.

import React가 불필요하게 된 이유 중 하나는 require() 구문이다. JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 불러오는 require 구문도 같이 추가되므로 import React from ‘react’를 작성하지 않아도 된다.

번들링 사이즈를 조금이라도 줄이고자 한다면 아래의 명령어로 import React를 모두 삭제할 수 있다.

```jsx
npx react-codemod update-react-imports
```

### 10.1.4 그 밖에 주요 변경 사항

**이벤트 풀링 제거**

- 이벤트 풀링: SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미한다.

이벤트 풀링은 다음과 같이 이벤트가 발생한다.

1. 이벤트 핸들러가 이벤트를 발생시킨다.
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

비동기 코드로 이벤트 핸들러에 접근하기 위해서는 이러한 방식으로 별도 메모리 공간에 합성 이벤트 객체를 할당해야 하는 점, 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안 된다는 점 때문에 이러한 이벤트 풀링 개념이 삭제됐다.

**useEffect 클린업 함수의 비동기 실행**

리액트 17에서는 클린업 함수가 비동기적으로 실행된다. (컴포넌트의 커밋 단계가 완료될 때까지 지연된다.)

따라서 리렌더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 조금이나마 빨라졌다.

**컴포넌트의 undefined 반환에 대한 일괄적인 처리**

리액트 16에서 forwardRef나 memo에서 undefined를 반환하는 경우, 별다른 에러가 발생하지 않는 문제가 있었다.

그러나 17부터는 에러가 정상적으로 발생한다. 18부터는 undefined를 반환해도 에러가 발생하지 않는다.

## 10.2 리액트 18 버전 살펴보기

18로 넘어오면서 가장 큰 변경점은 동시성 지원이다. 

### 10.2.1 새로 추가된 훅 살펴보기

**useId**

컴포넌트별로 유니크한 값을 생성하는 훅이다. 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있게 된다.

**useTransition**

```jsx
const [isPending, startTransition] = useTransition();
```

UI 변경을 가로막지 않고 상태를 업데이트 할 수 있는 리액트 훅이다. 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있어 사용자 경험이 향상된다.

즉 렌더링에 시간이 소요되는 컴포넌트는 동기 방식으로 브라우저의 다른 작업을 방해하면서 즉각 렌더링을 시작하지 않고, async await처럼 비동기로 렌더링한다.

useTransition은 리액트 18 변경 사항의 핵심 중 하나인 **동시성**(concurrency)을 다룰 수 잇는 새로운 훅이다.

과거 리액트의 모든 렌더링은 동시적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 useTransition과 같은 동시성을 지원하는 기능을 사용하면 **느린 렌더링 과정에서 로딩 화면**을 보여주거나 **지금 진행중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.**

useTransition은 컴포넌트에서만 사용가능한 훅이며, 훅을 사용할 수 없는 상황이라면 단순히 stratTransition을 바로 import 할 수 있다.

**useDeferredValue**

리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.

디바운스와 비슷하지만 useDeferredValue만이 가진 장점이 몇 가지 있다.

먼저 디바운스는 고정된 지연 시간을 필요로 하지만 useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 useDeferredValue로 지연된 렌더링을 수행한다. 

따라서 이 **지연된 렌더링은 중단할 수도 있고, 사용자의 인터렉션을 차단하지도 않는다.**

useTransition과의 차이는 뭘까?

- useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state값 자체만을 감싸서 사용한다.
- 방식에만 차이가 있을 뿐, 지연된 렌더링을 한다는 점에서 모두 동일한 역할을 한다.

만약 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트 할 수 있는 코드에 접근할 수 있다면 useTransition을 사용하는 것이 좋다. 

그러나 컴포넌트의 props와 같이 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 usdDeferredValue를 사용하는 것이 타당하다.

**useSyncExternalStore**

useTransition과 useDeferredValue와 같은 훅처럼 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 **동시성 이슈**가 발생할 수 있다. 

리액트가 관리하는 state라면 훅에서 내부적으로 문제를 처리하겠지만 리액트에서 관리할 수 없는 외부 데이터 소스는 리액트에서 추구하는 동시성 처리가 추가돼 있지 않다면 **테어링** 현상이 발생할 수 있다. 이를 해결하기 위한 훅이**useSyncExternalStore**이다.

```jsx
useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);

// subscribe: (callback) => Unsubscribe
// getSnapshot: () => State
// getServerSnapshot?:
```

**subscribe**

- 첫 번째 인자 subscribe는 콜백 함수를 받아 스토어에 등록한다.
- 스토어에 있는 값이 변경되면 이 콜백이 호출돼야 한다.
- useSyncExternalStore는 이 훅을 사용하는 컴포넌트를 리렌더링한다.

**getSnapshot**

- 두 번째 인자 getSnapshot은 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수다.
- 스토어가 변경되지 않았다면 매번 함수를 호출할 때마다 동일한 값을 반환해야 한다.
- 스토어에서 값이 변경됐다면 이전 값과 Object.is로 비교해 값이 변경됐다면 컴포넌트를 리렌더링한다.

**getServerSnapshot**

- 세 번째 인자는 옵셔널 값으로 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용한다.
- 서버사이드에서 렌더링되는 훅이라면 반드시 이 값을 넘겨주어야한다.
- 클라이언트 값과 불일치가 발생할 경우 오류가 발생한다.

### 10.2.4 자동 배치(Automatic Batching)

리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다. 

```jsx
const handleClick = () => {
  setCount(prev => prev + 1);
  setToggle(prev => !prev);
};

console.log('render'); // handleClick 실행 시 한 번만 호출된다.
```

위 예제에서는 handleClick을 통해 두 개의 상태를 변경시킨다. 하지만 리액트는 두 개 이상의 state에 대한 업데이트를 하나의 리렌더링으로 묶어서 수행하는데 이것을 자동 배치라고 한다.

리액트 17버전에서 자동 배치가 없던 것은 아니지만 이벤트 핸들러 내부가 아닌 Promise, setTimeout과 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았다. 즉, 동기와 비동기 배치 작업에 일관성이 없었다.

리액트 18 버전부터 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있다.

**flushSync()**

flushSync는 배치 작업을 하지 않고 동기적으로 상태를 변경하여 강제적으로 리렌더링을 발생시킨다.

### 10.2.5 더욱 엄격해진 엄격 모드

**리액트의 엄격 모드**

리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트다.

- 더 이상 안전하지 않은 특정 생명주기를 사용 시 경고
- 문자열 ref 사용 금지
- findDOMNode에 대한 경고
- 구 Context API 사용 시 경고
- 예상치 못한 부작용(side-effects) 검사
    - 클래스 컴포넌트의 constructor, render, shouldComponentUpdate, getDerivedStateFromProps
    - 클래스 컴포넌트의 setState 첫 번째 인수
    - 함수형 컴포넌트의 body
    - useState, useMemo, useReducer에 전달되는 함수

두 번 씩 실행되는 이유는 함수형 프로그래밍 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이고, 엄격 모드에서는 앞에서 언급한 내용이 실제로 지켜지고 있는지, 즉 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜 주기 위해 두 번 실행하게 된다. 

즉, 리액트에서는 state, props, context가 변경되지 않는 한 항상 동일한 JSX를 반환해야 한다.

**리액트 18에서 추가된 엄격 모드**

- 향후 리액트에서는 컴포넌트가 언마운트 되었을 때도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정
- 따라서 최조해 마운트 될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두번째 마운트에서 이전 상태를 복원함
- 이후에 있을 변경을 위해 고의로 useEffect를 두 번 작동시키는 내용을 추가했다. 이를 위해 useEffect를 사용할 때 반드시 적절한 cleanup 함수를 배치해 반복 실행 될 수 있는 useEffect로부터 최대한 자유로운 컴포넌트를 만들어야 한다.

### 10.2.6 Suspense 기능 강화

컴포넌트를 동적으로 가져올 수 있게 도와주는 기능이다.

18 이전의 Suspense는 몇 가지 문제점이 있었다.

1. 기존의 Suspense는 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
2. Suspense는 서버에서 사용할 수 없었다.

18에서는 정상적으로 지원되며 변경내용은 다음과 같다.

1. 아직 마운트되기 직전임에도 effect가 빠르게 실행되는 문제가 수정됐다.
2. Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다.
3. 서버에서도 실행할 수 있게 된다.
4. 화면이 너무 자주 업데이트되어 시각적으로 방해받는 것을 방지하기 위해 스로틀링이 추가됐다.

### 10.2.7 익터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

인터넷 익스플로러 지원 중단에 따라 리액트 어플리케이션은 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포된다.

- Promise
- Symbol
- Object.assign

위 세 가지 기능을 지원하지 않는 브라우저에서 서비스해야 한다면 이 세 가지 기능을 위한 폴리필을 반드시 추가해야한다.

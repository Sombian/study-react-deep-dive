# 2장 리액트 핵심 요소 깊게 살펴보기

### 2.1 JSX란?

JSX는 리액트의 전유물인가? 반은 맞고 반은 틀리다.

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다. 

JSX는 페이스북에서 독자적으로 개발한 문법이며 ECMAScript 라고 불리는 자바스크립트 표준의 일부는 아니다. 따라서 반드서 트랜스파일러를 거쳐야 JS가 이해할 수 있는 자바스크립트 코드로 변환된다.

JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법이다.

##### 2.1.1 JSX의 정의
- JSXElement
- JSXAttributes
- JSXChildren
- JSXStrings

##### 2.1.2 JSX 예제

##### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- @babel/plugin-transform-react-jsx 플러그인이 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.
- 반환값은 결국 React.createElement로 귀결된다.

##### 2.1.4 정리

- JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다.

### 2.2 가상 DOM과 리액트 파이버

##### 2.2.1 DOM과 브라우저 렌더링 과정

DOM이란 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

- 브라우저의 렌더링 과정

	1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
    
    2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리 (DOM)을 만든다.
    
    3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
    
    4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
    
    5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서이다.
    
    6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
    
        - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정, 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.

        - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

##### 2.2.2 가상 DOM의 탄생 배경

렌더링 과정은 매우 복잡하고 많은 비용이 든다. 여기서 사용자의 인터랙션이 더해지면 훨씬 복잡한 작업을 수행해야 한다.

특히 Single Page Application 에서는 페이지가 변경되는 경우 하나의 페이지에서 계속해서 요소의 위치를 재계산하기 때문에 그만큼 DOM을 관리하는 과정에서 부담해야 할 비용이 커진다.

이 문제를 해결하기 위해 탄생한 것이 바로 가상 DOM이다.

가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료되었을 때 실제 브라우저의 DOM에 반영한다.

가상 DOM은 브라우저에서 변경이 일어나는 것이 아니라 메모리에서 계산하는 과정을 거치는 것이기 때문에 브라우저와 개발자의 부담을 덜 수 있다.

##### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

**리액트 파이버란?**

파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 이는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준로 화면에 렌더링을 요청하는 역할을 한다.

* 재조정(reconciler): 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이다.

파이버의 역할은 다음과 같다.
- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

이 모든 과정은 비동기로 일어난다. 이는 리액트의 비효율성으로 이어졌고 리액트 팀은 파이버라는 개념을 탄생시킨다.

파이버는 하나의 작업 단위로 구성돼 있으며 리액트는 이러한 작업 단위를 하나씩 처리하고 finishWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.
이 단계는 아래 두 단계로 나눌 수 있다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업 commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

**리액트의 파이버 트리**

파이버 트리는 리액트 내부에서 두 개가 존재한다. 하나는 현재 모습을 담은 파이버 트리고 다른 하나는 작업 중인 상태를 나타내는 workInProgree 트리다. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. 이런 기술을 더블 버퍼링이라고 한다.

##### 2.2.4 파이버와 가상 DOM

리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기 때문에 파이버와 가상 DOM은 동일한 개념이 아니다. 

##### 2.2.5 정리
가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것이다. 

### 2.3 클래스 컴포넌트와 함수 컴포넌트
##### 2.3.1 클래스 컴포넌트
**클래스 컴포넌트의 생명주기 메서드**

생명주기 메서드가 실행되는 시점은 다음과 같다.
- 마운트: 컴포넌트가 마운팅(생성)되는 시점
- 업데이트: 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점

생명주기 메서드들은 다음과 같다.
1. render()

- 리액트 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰인다. 컴포넌트가 UI 렌더링을 하기 위해 쓰이며, 마운트와 업데이트 과정에서 일어난다.
- 함수는 부수효과가 없어야 한다.	같은 입력값이 들어가면 항상 같은 결과물을 반환해야 한다. 따라서 함수 내부에 state를 직접 업데이트 하는 this.setState를 호출해서는 안 된다.

2. componentDidMount():
- 컴포넌트가 마운트되고 준비되는 즉시 실행된다. this.setState()로 state 값을 변경하는 것이 가능하다. 일반적으로 state나 props 변화에 따라 DOM 업데이트 등에 쓰인다.

3. componentWillUnMount()
- setState를 호출할 수 없다. API 호출을 취소하거나 setInterval, setTimeout 타이머를 지우는 작업에 유용하다.

4. shouldComponentUpdate()
- state나 Props의 변경으로 리렌더링 되는 것을 막고 싶다면 이 메서드를 사용하면 된다.

5. static getDerivedStateFromProps()
- render()를 호출하기 직전에 호출되며 여기서 반환하는 객체는 state로 들어간다.

6. getSnapShotBeforeUpdate()
- DOM이 업데이트되기 직전에 호출되어 componentDidUpdate로 반환값이 전달된다. DOM에 렌더링 되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 작업에 유용하다.

7. getDerivedStateFromError()
- 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드이다.

8. componentDidCatch()
- 자식 컴포넌트에서 에러가 발생했을 때 실행, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다. 커밋 단계에서 실행되기 때문에 getDerivedStateFromError()에서 하지 못했던 부수 효과를 수행할 수 있다.

**클래스 컴포넌트의 한계**
- 데이터의 흐름을 추적하기 어렵다.

- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다.
- 핫 리로딩을 하는 데 상대적으로 불리하다.

##### 2.3.2 함수 컴포넌트
##### 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트
**생명주기 메서드의 부재**

함수형 컴포넌트는 useEffect 를 활용해서 생명주기 메서드를 비슷하게 구현할 수 있다.

**함수 컴포넌트와 렌더링된 값**

함수 컴포넌트는 렌더링 된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.

클래스 컴포넌트는 props의 값을 항상 this로부터 가져온다. this 가 가리키는 객체는 변경 가능한 값이다. 따라서 부모 컴포넌트가 props를 변경해 컴포넌트가 다시 렌더링 됐다는 것은 this.props의 값이 변경된 것이다.

함수 컴포넌트는 props를 인수로 받기 때문에 컴포넌트는 그 값을 변경할 수 없고, 해당 값을 그대로 사용하게 된다.

### 2.4 렌더링은 어떻게 일어나는가?
##### 2.4.1 리액트의 렌더링이란?

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

##### 2.4.2 리액트의 렌더링이 일어나는 이유
1. 최초 렌더링: 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링: 처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의마한다.
	
    - 클래스 컴포넌트의 setState가 실행되는 경우
    - 클래스 컴포넌트의 forceUpdate가 실행되는 경우
    - 함수 컴포넌트의 useState()
    - 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
    - 컴포넌트의 key props가 변경되는 경우
    	- 리액트 파이버 트리 구조를 떠올려보면, 리렌더링 시 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트가 변경이 있었는지 구별해야 하는데, 변경점을 구별해주는 것이 바로 key이다. 따라서 key가 없다면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.
   	- props가 변경되는 경우
   	- 부모 컴포넌트가 렌더링 될 경우: 부모가 렌더링되면 자식도 무조건 렌더링 된다. 


mobx-react나 react-redux와 같은 리액트 패키지는 리액트의 리렌더링으로 이어지지는 않는다. 라이브러리 어디에선가 각자의 방법으로 상태를 관리한다.

##### 2.4.3 리액트의 렌더링 프로세스
리액트의 렌더링은 렌더 단계와 커밋 단계라는 두 단계로 분리외어 실행된다.

##### 2.4.4 렌더와 커밋
1. 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.
2. 커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계 이후에 브라우저 렌더링이 발생한다.

중요한 사실은 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.

렌더링을 수행했으나 커밋단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

##### 2.4.5 일반적인 렌더링 시나리오 살펴보기
컴포넌트를 렌더링 하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 

### 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

##### 2.5.1 주장1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 비용이 든다. 따라서 신중하게 고려해야 한다.

##### 2.5.2 주장2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자
memmo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 사용
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트엑서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

따라서 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

### 새롭게 알게 된 것
- JSX는 리액트에 종속적이지 않은 독자적 문법이다. 

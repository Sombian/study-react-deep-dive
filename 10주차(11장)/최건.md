# 11장

## Next.js 13

### App Router

Next.js 12 까지는 공통 레이아웃(e.g. react-router에서의 `<Outlet>`)을 구현할 수 있는 방법은 _app 이 유일했다. 그러나 해당 방식은 제한적이고, 각 페이지별로 서로 다른 레이아웃을 지원하지 못했다. 이러한 페이지 라우터의 문제점을 해결하기 위해 Next.js 13 부터는 앱 라우터를 제공한다.

앱 라우터 또한 파일 기반 라우팅을 사용하지만, 기존의 페이지 라우터에서 파일의 이름(e.g. `/pages/a/b.tsx` == `/pages/a/b/index.tsx`)을 주소로 사용하는 것과 달리 앱 라우터에서는 폴더명(e.g. `app/a/b/page.tsx`)으로 주소를 표현한다. 즉, 단일 경로에 대해서 중복 표현을 허용하지 않는다.

#### page.tsx

폴더명에 해당하는 주소의 페이지를 설정하는 파일이다. 해당 파일에는 반드시 `export default`로 내보내는 컴포넌트가 있어야한다.

```tsx
export default Page()
{
	return <main>hello world</main>;
}
```

#### layout.tsx

폴더명에 해당하는 주소 및 하위 주소에 공통된 레이아웃을 설정하는 파일이다. 루트 레이아웃은 반드시 요구되며, 각 레이아웃은 중첩이 가능하다.

```tsx
export default Layout({ children })
{
	return <div>{children}</div>;
}
```

#### error.tsx

폴더명에 해당하는 주소에 에러 바운더리(Error Boundery)를 설정하는 파일이다. 에러 바운더리는 클라이언트에서만 작동하며, 레이아웃에서 발생한 오류를 검출하기 위해서는 상위 경로의 error.tsx를 사용해야한다.

```tsx
export default Error({ error, reset })
{
	return <div>{error?.message}</div>;
}
```

#### not-found.tsx

폴더명에 해당하는 주소의 지원하지 않는 하위 경로에 접근할 경우의 페이지(404)를 설정하는 파일이다.

```tsx
export default NotFound()
{
	return <div>404</div>;
}
```

#### loading.tsx

React.Suspense를 기반으로 컴포넌트를 불러오는 동안 표기할 페이지를 설정하는 파일이다.

```tsx
export default Loading()
{
	return <div>...</div>;
}
```

#### route.ts

폴더명에 해당하는 주소에 API 요청을 보낼 경우 반환할 응답을 설정하는 파일이다. page.tsx와 route.ts는 공존할 수 없다.

```tsx
export async function GET(request: Request)
{
	return new Response(JSON.stringify({ name: "hello" }), { status: 200, headers: { "Content-Type": "application/json" } });
}
```

### React Server Component

리액트 18에서 새로 도입된 서버 컴포넌트는 서버 사이드 렌더링과 완전히 다른 개념이다. 두 용어 모두 '서버''라는 단어가 포함되어 있어 혼동의 여지가 있지만, '서버'에서 무언가 작업을 수행하는 것을 제외하면 다른 개념으로 보는 것이 옳다.

#### 기존 SSR의 한계

SSR의 경우 서버에서 사전에 생성한 DOM을 우선적으로 받은다음 하이드레이션을 진행한다.

한계 1)

하이드레이션을 통해 초기 렌더링 시간은 단축할 수 있지만, 결국에는 JS를 받아 사용하는 과정이 포함된다. 용량이 큰 외부 의존성을 사용하는 경우에는 해당 문제가 특히나 부각된다.
->
만약 이러한 의존성을 실행한 결과를 서버에서 전송한다면 클라이언트의 부담을 대폭 줄일 수 있다.

한계 2)

백엔드 리소스에 대한 직접적인 접근이 불가능하다. 클라이언트에서 백엔드 데이터에 접근하는 방법은 REST API가 대표적이다. 이러한 방법은 편리하지만 백엔드에서 항상 클라이언트에서 데이터를 접근하기 위한 방법을 마련해야 한다는 불편함이 있다.
->
만약 직접 클라이언트에서 백엔드에 접근해 원하는 정보를 가져올 수 있다면 이러한 불편함을 해소할 수 있다.

이 외에도 코드 분할이 불가능한 점, 연속적인 요청의 경우 병목 현상이 발생할 수 있는 점, 및 기타의 한계가 존재한다.

결국 SSR, CSR 모두 이러한 문제들을 해결하기에는 조금씩 아쉬움이 있다. SSR은 정적 요소를 빠르게 제공하고, 서버 데이터 접근이 손쉬운 반면 높은 반응성을 제공하기에는 무리가 있다. 반면 CSR은 높은 반응성을 제공할 수 있지만 SSR에 비해 초기 렌더링이 느리고 서버에서 데이터를 가져오는 것 또한 번거롭다. 이러한 두 구조의 방법을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트이다.

#### 서버 컴포넌트?

서버 컴포넌트는 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법이다. 서버에서 할 수 있는 작업은 서버에서, 서버가 할 수 없는 나머지 작업은 클라이언트에 수행된다. 서버 환경은 브라우저에 존재하지 않기 때문에 클라이언트 컴포넌트는 서버 컴포넌트를 참조(import)할 수 없다.

[서버 컴포넌트]

**PROS**

- 서버에서 실행되기에 서버의 호스트 객체 및 정보에 바로 접근이 가능하다.
- 비동기 컴포넌트의 작성이 가능하다.

**CONS**

- 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다. 따라서 useState, useReducer 등의 훅을 사용할 수 없다.
- 렌더링 생명주기를 사용할 수 없다. 따라서 useEffect, useLayoutEffect 등의 훅을 사용할 수 없다.
- 서버에서만 실행되기 때문에 브라우저 호스트 객체(e.g. window, document)에 접근이 불가능하다.

서버 컴포넌트는 사용자의 요청을 받으면 DOM을 표현한 JSON 형태의 정보(wire format)을 스트리밍을 통해 클라이언트에 제공하고, 브라우저는 해당 정보를 토대로 분할되어 전송되는 컴포넌트를 조합해 리액트 컴포넌트 트리를 구성한다.

### fetch

앱 라우터는 과거 Next.js의 SSR과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getInitialProps을 미지원하며, 모든 데이터 요청은 웹 표준 API인 fetch를 기반으로 수행된다.

또한 서버 컴포넌트의 경우, fetch를 사용하면 트리 내에서 동일한 요청이 있다면 요청 비용 절감을 위한 caching을 지원한다.

### Server Action

API를 별도로 생성하지 않아도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다. 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.

```tsx
async function server_action()
{
	"use server";
	// 서버에서 실행할 코드
}
```

# 11장\_Next.js 13과 리액트 18

## app 디렉터리의 등장

- 13버전 이전까지 모든 페이지는 각각 구별된 파일로 독립되어 있었다.
- 페이지 공통으로 무언가를 넣을 수 있는 곳은 `_document`, `_app`이 유일하다.

`_document`

페이지에서 쓰이는 과 태그를 수정하거나 서버 사이드 렌더링 styled-components 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용한다.

`_app`

페이지를 초기화하기 위한 용도로 사용되며 다음과 같은 작업이 가능하다.

- 페이지 변경 시에 유지하고 싶은 레이아웃
- 페이지 변경 시 상태 유지
- componentDidCatch 를 활용한 에러 핸들링
- 페이지간 추가적인 데이터 삽입
- global CSS 주입

페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다.

### 라우팅

페이지 라우팅 방식이다.

app 디렉터리 내부의 파일명은 라우팅에 아무런 영향을 미치지 못했다.

**layout.js**

Next.js 13 부터는 app 디렉터리 내부의 폴더명이 라우팅이 된다.

해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다.

```jsx
// app/layout.tsx

import { ReactNode } from 'react'

export default function AappLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="ko">
      <head>
        <title>안녕하세요!</title>
      </head>
      <body>
        <h1>웹페이지에 오신 것을 환영합니다.</h1>
        <main>{children}</main>
      </body>
    </html>
  )
}

//app/blog/layout.tsx

import { ReactNode } from 'react'

export default function BlogLayout({ children }: { children: ReactNode }){
  return <section>{children}</section>
}
```

app/layout.tsx: 루트에는 단 하나의 layout 을 만들 수 있다. 이 layout 은 모든 페이지에 영향을 미치는 공통 레이아웃이다.

app/blog/layout.tsx: 페이지 하위에 추가되는 layout은 해당 주소 하위에만 적용된다.

**page.js**

페이지를 의미한다.

**error.js**

공통 에러 컴포넌트이다.

클라이언트 컴포넌트에서만 작동된다.

**not-found.js**

404 페이지를 렌더링할 때 사용된다.

**loading.js**

Suspense 기반으로, 해당 컴포넌트가 로딩할 때를 표시할 수 있다.

**route.js**

http 메서드를 정의한다.

## 리액트 서버 컴포넌트

기존 리액트 컴포넌트와 SSR의 한계는 다음과 같다.

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청에 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

해당 문제는 리액트가 클라이언트 중심으로 돌아가기에 발생하는 문제이다.

서버 사이드 렌더링, 클라이언트 사이드 렌더링의 장점을 모두 취하고자 하는 것이 리액트 서버 컴포넌트이다.

### 서버 컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버, 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법이다.
- 요청이 오면 딱 한번 실행되므로 상태를 가질 수 없다.(useState)
- 렌더링 생명주기(useEffect)를 사용할 수 없다.
- 서버에서만 실행되기에 DOM API, window, document 등에 접근할 수 없다.
- 데이터베이스, 내부 서비스 등 서버에만 있는 데이터를 비동기로(async, await) 접근할 수 있다.
- 다른 서버 컴포넌트, 엘리먼트, 클라이언트 컴포넌트를 렌더링할 수 있다.

### 서버 사이드 렌더링과 서버 컴포넌트의 차이

**서버 사이드 렌더링**

- 응답받은 페이지 전체를 HTML으로 렌더링하는 과정을 서버에서 수행, 그 결과를 클라이언트에 내려준다.
- 하이드레이션을 거쳐, 서버의 결과물이 입혀지고, 이벤트가 붙는다.

→ 초기 인터렉션은 수행할 수 없지만, HTML을 빠르게 내려줘 사용자 경험을 증대시킨다.

서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공하고, 클라이언트 컴포넌트는 SSR로 초기 HTML을 빠르게 제공받을 수 있다.

## Next.js에서의 리액트 서버 컴포넌트

Next.js 13부터 도입되었다.

### 새로운 fetch 도입, getServerSideProps, getStaticProps, getInitialProps 삭제

/app 내부에서 위의 get… 이 삭제되고, 모든 데이터 요청을 fetch API 기반으로 이루어진다.

### 정적 렌더링, 동적 렌더링

- 정적 라우팅
  기본적으로 빌드 타임에 렌더링을 미리 하고, 캐싱해서 재사용할 수 있게끔 해두었다.
- 동적 라우팅
  서버에서 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.

### 캐시와 mutating, **revalidating**

fetch의 기본 작동을 재정의하였다.

해당 데이터의 유효 시간을 정하고, 이 시간이 지나면 다시 데이터를 불러와서 렌더링하는 것이 가능해졌다.

### 스트리밍을 활용한 점진적인 페이지 불러오기

서버사이드 렌더링은 렌더링 요청받은 페이지를 모두 렌더링할 때까지 사용자는 빈 페이지를 보게 되었다.

HTML을 작게 쪼개서 완성하는 대로 보내, 사용자가 일부의 페이지와 인터렉션을 할 수 있게 되었다.

TTFB, FCP을 개선하는데 도움이 된다.

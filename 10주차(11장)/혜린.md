# 11장 Next.js 13과 리액트 18

# 11.1 app 디렉터리의 등장

## 11.1.1 라우팅

**라우팅을 정의하는 법**

- 페이지 라우팅: `/pages/a/b.tsx`, `/pages/a/b/index.tsx`는 모두 동일한 주소로 변환된다.
- app 라우팅: `/app/a/b`는 `/a/b`로 변환되며, 파일명은 무시된다. 폴더명만 주소로 변환된다.

![image.png](11%E1%84%8C%E1%85%A1%E1%86%BC%20Next%20js%2013%E1%84%80%E1%85%AA%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%2018%20de0e1e82fb7c4a8092c10dbdbe29d9e2/image.png)

**layout.js**

공통 레이아웃을 적용할 수 있는 파일이다.

주의할 점은 다음과 같다.

- app 디렉터리 내부에서는 예약어다. 무조건 layout.{js|jsx|ts|tsx}로 사용해야 하며 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- [children](https://nextjs.org/docs/app/api-reference/file-conventions/layout#children-required)을 props로 받아서 렌더링해야 한다.
- 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- API 요청과 같은 비동기 작업을 수행할 수 있다.

**page.js**

Next.js에서 일반적으로 다뤘던 페이지를 의미한다.

**error.js**

해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다. 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.

- `ErrorBoundary`가 클라이언트에서만 작동하므로 `use client`를 명시해 클라이언트 컴포넌트로 작성해야 한다.

```jsx
"use client"; // 클라이언트 컴포넌트

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // 에러 로깅
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

- Layout에서 발생한 에러를 처리하고자 한다면 app/global-err.js 페이지를 생성하면 된다.

**not-found.js**

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링한다.
- 전체 애플리케이션에 대해 노출하고 싶다면 `app/not-found.js`를 생성하면 된다.

**loading.js**

- Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용된다.

**route.js**

- /pages/api와 동일하게 /app/api를 기준으로 디렉터리 라우팅을 지원하며, /api에 대해서도 파일명 라우팅이 없어졌다.
- 메서드명을 예약어로 선언해 두면 HTTP 요청에 맞게 작동한다.
- api 폴더가 아닌 다른 곳(e.g. `apps/internal-api/hello/route.ts`)에 선언해도 작동한다. 대신 route.ts가 존재하는 폴더 내부에는 page.tsx가 공존할 수 없다.

route 함수들이 받을 수 있는 파라미터는 다음과 같다. 

- `request`: fetch의 request가 확장된 NextRequest 객체다.
- `context`: params만을 가지고 있으며 동적 라우팅 파라미터가 포함되어 있다.

# 11.2 리액트 서버 컴포넌트

## 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

1. 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
2. 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
3. 자동 코드 분할(code split)이 불가능하다.
4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
5. 추상화에 드는 비용이 증가한다.

## 11.2.2 서버 컴포넌트란?

1. 서버 컴포넌트
    
    하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 랜더링할 수 있는 기법
    
    - effect 나 state 에 의존하지 않고 서버에서 제공할 수 있는 기능을 사용하는 훅은 사용이 가능하다.
    - 서버에서 실행되기 때문에 DOM API 를 쓰거나 window, document 등에 접근할 수 없다.
    - 서버에만 있는 데이터를 async/await로 접근할 수 있다. 컴포넌트 자체가 async한 것이 가능하다.
2. 클라이언트 컴포넌트
    - 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
    - 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.
3. 공용 컴포넌트
    - 서버와 클라이언트 모두에서 사용할 수 있다. 당연히 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

## 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 랜더링
    - 응답받은 페이지 전체를 서버에서 랜더링해서 클라이언트에 내려준다. 이 후 하이드레이션 과정을 거쳐서 결과물에 이벤트를 붙이는 작업을 수행한다.
    - 서버 사이드 렌더링의 목적은 초기에 인터렉션은 불가능 하지만 정적 HTML를 빠르게 내려주는데 초점을 두고 있다.
    - HTML을 로딩한 후에 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는 데 비용이 든다.

이후 서버사이드 랜더링과 서버컴포넌트를 모두 채택하는 것이 가능해질 예정이다.

- 서버 컴포넌트를 활용해서 서버에서 랜더링할 수 있는 컴포넌트는 서버에서 완성해서 제공 받은 다음,
- 클라이언트 컴포넌트는 서버사이드 랜더링을 이용해서 HTML으로 빠르게 전달 받을 것이다.
- 즉 이둘은 대체제가 아닌 상호보완하는 개념으로 보아야 한다.

## 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 랜더링 요청을 받는다. 
    - 서버컴포넌트를 사용하는 모든 페이지는 서버에서 시작되고, 루트 컴포넌트도 항상 서버 컴포넌트이다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON 으로 직렬화 한다
    - 서버에서 랜더링 할 수 있는 부분은 직렬화한다. ( 와이어 포맷 M: 클라이언트 컴포넌트, S: Suspense, J: App.server.js )
    - 클라이언트 컴포넌트 표시된 부분은 플레이스 홀더 형식으로 비워두고 나타낸다.
3. 브라우저는 서버로 부터 스트리밍으로 JSON 결과물을 받으면 
    - 이를 파싱해서 트리를 재구성해
    - 컴포넌트를 랜더링하고 브라우저의 DOM 에 커밋할 것이다.

# 11.3 Next.js 에서의 리액트 서버 컴포넌트

리액트 팀은 서버 컴포넌트를 온전히 사용하기 위해 번들러와 프레임워크의 도움이 필수라고 언급했다. Next.js 도 13버전에서 서버 컴포넌트를 도입했고 /app 디렉토리에 구현되어있다.

## 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

과거 Next.js 의 서버사이드 랜더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getInitialProps가 /app 내부에서 삭제되고 모든 데이터 요청을 fetch API 기반으로 이뤄진다.

- 서버사이드 랜더링이 아니어도 서버에서 데이터를 직접 불러올 수 있다.
- 컴포넌트가 비동기적으로 데이터가 불러와지면 페이지를 랜더링해서 클라이언트로 전달하는 것도 가능해진다
- 추가로 fetch API 가 요청 중복되는 것도 방지했다.

## 11.3.2 정적 렌더링과 동적 렌더링

- fetch option 으로 데이터 캐싱 여부를 결정하며
- generateStaicParams 를 사용해 과거 Next.js 의 getStaticPaths 를 흉내 낼수도 있다.

## 11.3.3 캐시와 mutating, 그리고 revalidating

revalidate 변수를 선언해서 특정 시간이 지났을 때 데이터를 갱신하도록 설정할 수 있다. 이 작업은 서버에서 루트부터 데이터를 전체적으로 가져와 갱신함으로 브라우저나 react 의 state 의 영향을 미치지 않는다.

## 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거 서버사이드 랜더링은 랜더링 요청받은 페이지를 모두 랜더링 할때 까지 사용자는 빈페이지를 보게 되었다.
- 이를 해결하기 위해 HTML 을 작게 쪼개서 완성되는 대로 보내고, 사용자는 일부라도 페이지와 인터랙션을 할 수 있게 된다.

이는 핵심 웹 지표인 TTFB(최초 바이트까지의 시간), FCP(최초 콘텐츠풀 페인팅)을 개선하는 데 큰 도움을 준다.

이 스트리밍을 활용할 수 있는 방법은 두 가지이다.

- loading.tsx 를 배치 하거나
- 리액트 Suspense 컴포넌트를 배치하면 된다.

# **11.4 웹팩의 대항마, 터보팩의 등장 (beta)**

- Rome, SWC, esbuild 는 기존 자바스크립트로 만들어져 제공되던 기능을 Rust 나 go 같은 언어를 활용함으로 자바스크립트 대비 월등히 뛰어난 성능을 보여준다
- Turbopack 역시 러스트 기반으로 작성되어 웹팩 대비 700배 빠르다고 소개되며 안정화되어 정식버전이 출시될 것을 기대하고 있다.

# **11.5 서버 액션(alpha)**

API를 생성하지 않고 함수 수준에서 서버에 직접 접근해 데이터 요청을 수행할 수 있는 기능이다.

- next.config.js 에서 실험기능을 활성화 해야한다.
- 'use server' 지시자를 선언하고, async 로 함수를 작성해야한다.
- 다음과 같은 작업을 수행할 수 있다.

## 11.5.1 form의 action

- 현재 라우트 주소와 ACTION_ID 를 보내면 서버에서 실행할 내용을 찾아 직접 실행한다.
- 이 모든 과정이 페이지 새로고침 없이 수행된다.
- form을 기반으로 데이터 추가 및 수정을 좀더 자연스럽게 수행할 수 있다.

## 11.5.2 input의 submit 과 image의 form action

## 11.5.3 startTransition 과의 연동

## 11.5.4 server mutation 이 없는 작업
